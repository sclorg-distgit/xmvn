From 06cbffad8f5609188a788e85991918078d9fca12 Mon Sep 17 00:00:00 2001
From: Mikolaj Izdebski <mizdebsk@redhat.com>
Date: Wed, 7 Jan 2015 10:21:15 +0100
Subject: [PATCH 4/4] Port to Modello 1.7

---
 xmvn-core/pom.xml                                  |    2 -
 .../org/fedoraproject/xmvn/config/Artifact.java    |  197 ++++
 .../fedoraproject/xmvn/config/BuildSettings.java   |  148 +++
 .../fedoraproject/xmvn/config/Configuration.java   |  343 ++++++
 .../xmvn/config/InstallerSettings.java             |  108 ++
 .../fedoraproject/xmvn/config/PackagingRule.java   |  374 +++++++
 .../org/fedoraproject/xmvn/config/Repository.java  |  308 ++++++
 .../xmvn/config/ResolverSettings.java              |  310 ++++++
 .../org/fedoraproject/xmvn/config/Stereotype.java  |  122 +++
 .../config/io/stax/ConfigurationStaxReader.java    | 1139 ++++++++++++++++++++
 .../config/io/stax/ConfigurationStaxWriter.java    |  597 ++++++++++
 .../config/io/stax/IndentingXMLStreamWriter.java   |  653 +++++++++++
 .../fedoraproject/xmvn/metadata/ArtifactAlias.java |  157 +++
 .../xmvn/metadata/ArtifactMetadata.java            |  520 +++++++++
 .../fedoraproject/xmvn/metadata/Dependency.java    |  323 ++++++
 .../xmvn/metadata/DependencyExclusion.java         |  103 ++
 .../xmvn/metadata/PackageMetadata.java             |  270 +++++
 .../xmvn/metadata/SkippedArtifactMetadata.java     |  159 +++
 .../metadata/io/stax/IndentingXMLStreamWriter.java |  653 +++++++++++
 .../xmvn/metadata/io/stax/MetadataStaxReader.java  |  950 ++++++++++++++++
 .../xmvn/metadata/io/stax/MetadataStaxWriter.java  |  490 +++++++++
 xmvn-parent/pom.xml                                |    2 +-
 22 files changed, 7925 insertions(+), 3 deletions(-)
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Artifact.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/BuildSettings.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Configuration.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/InstallerSettings.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/PackagingRule.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Repository.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/ResolverSettings.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Stereotype.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/ConfigurationStaxReader.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/ConfigurationStaxWriter.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/IndentingXMLStreamWriter.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/ArtifactAlias.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/ArtifactMetadata.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/Dependency.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/DependencyExclusion.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/PackageMetadata.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/SkippedArtifactMetadata.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/IndentingXMLStreamWriter.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/MetadataStaxReader.java
 create mode 100644 xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/MetadataStaxWriter.java

diff --git a/xmvn-core/pom.xml b/xmvn-core/pom.xml
index 1c1808a..3c3f878 100644
--- a/xmvn-core/pom.xml
+++ b/xmvn-core/pom.xml
@@ -85,8 +85,6 @@
             <id>standard</id>
             <goals>
               <goal>java</goal>
-              <goal>stax-reader</goal>
-              <goal>stax-writer</goal>
             </goals>
           </execution>
         </executions>
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Artifact.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Artifact.java
new file mode 100644
index 0000000..96bb7ed
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Artifact.java
@@ -0,0 +1,197 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config;
+
+/**
+ * Identifier of Maven artifact.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Artifact
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Group ID of the artifact.
+     */
+    private String groupId = "";
+
+    /**
+     * Artifact ID of the artifact.
+     */
+    private String artifactId = "";
+
+    /**
+     * Version of the artifact.
+     */
+    private String version = "";
+
+    /**
+     * Classifier of the artifact.
+     */
+    private String classifier = "";
+
+    /**
+     * Maven stereotype of the artifact.
+     */
+    private String stereotype = "";
+
+    /**
+     * Extension of the artifact.
+     */
+    private String extension = "";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Artifact
+     */
+    public Artifact clone()
+    {
+        try
+        {
+            Artifact copy = (Artifact) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Artifact clone()
+
+    /**
+     * Get artifact ID of the artifact.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get classifier of the artifact.
+     * 
+     * @return String
+     */
+    public String getClassifier()
+    {
+        return this.classifier;
+    } //-- String getClassifier()
+
+    /**
+     * Get extension of the artifact.
+     * 
+     * @return String
+     */
+    public String getExtension()
+    {
+        return this.extension;
+    } //-- String getExtension()
+
+    /**
+     * Get group ID of the artifact.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Get maven stereotype of the artifact.
+     * 
+     * @return String
+     */
+    public String getStereotype()
+    {
+        return this.stereotype;
+    } //-- String getStereotype()
+
+    /**
+     * Get version of the artifact.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Set artifact ID of the artifact.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set classifier of the artifact.
+     * 
+     * @param classifier
+     */
+    public void setClassifier( String classifier )
+    {
+        this.classifier = classifier;
+    } //-- void setClassifier( String )
+
+    /**
+     * Set extension of the artifact.
+     * 
+     * @param extension
+     */
+    public void setExtension( String extension )
+    {
+        this.extension = extension;
+    } //-- void setExtension( String )
+
+    /**
+     * Set group ID of the artifact.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * Set maven stereotype of the artifact.
+     * 
+     * @param stereotype
+     */
+    public void setStereotype( String stereotype )
+    {
+        this.stereotype = stereotype;
+    } //-- void setStereotype( String )
+
+    /**
+     * Set version of the artifact.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/BuildSettings.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/BuildSettings.java
new file mode 100644
index 0000000..5b3e278
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/BuildSettings.java
@@ -0,0 +1,148 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config;
+
+/**
+ * Basic build settings.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class BuildSettings
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Whether detailed debugging information about the
+     * build
+     *             process should be logged.
+     *           
+     */
+    private Boolean debug;
+
+    /**
+     * 
+     *             Whether compilation and execution of unit and
+     * integration tests should be skipped.
+     *           
+     */
+    private Boolean skipTests;
+
+    /**
+     * 
+     *             Compatibility version of Java sources in the
+     * reactor. If
+     *             not specified then it defaults to 1.5 or
+     * whatever is
+     *             specified in configuration of Maven Compiler
+     * Plugin.
+     *           
+     */
+    private String compilerSource;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return BuildSettings
+     */
+    public BuildSettings clone()
+    {
+        try
+        {
+            BuildSettings copy = (BuildSettings) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- BuildSettings clone()
+
+    /**
+     * Get compatibility version of Java sources in the reactor. If
+     *             not specified then it defaults to 1.5 or
+     * whatever is
+     *             specified in configuration of Maven Compiler
+     * Plugin.
+     * 
+     * @return String
+     */
+    public String getCompilerSource()
+    {
+        return this.compilerSource;
+    } //-- String getCompilerSource()
+
+    /**
+     * Get whether detailed debugging information about the build
+     *             process should be logged.
+     * 
+     * @return Boolean
+     */
+    public Boolean isDebug()
+    {
+        return this.debug;
+    } //-- Boolean isDebug()
+
+    /**
+     * Get whether compilation and execution of unit and
+     * integration tests should be skipped.
+     * 
+     * @return Boolean
+     */
+    public Boolean isSkipTests()
+    {
+        return this.skipTests;
+    } //-- Boolean isSkipTests()
+
+    /**
+     * Set compatibility version of Java sources in the reactor. If
+     *             not specified then it defaults to 1.5 or
+     * whatever is
+     *             specified in configuration of Maven Compiler
+     * Plugin.
+     * 
+     * @param compilerSource
+     */
+    public void setCompilerSource( String compilerSource )
+    {
+        this.compilerSource = compilerSource;
+    } //-- void setCompilerSource( String )
+
+    /**
+     * Set whether detailed debugging information about the build
+     *             process should be logged.
+     * 
+     * @param debug
+     */
+    public void setDebug( Boolean debug )
+    {
+        this.debug = debug;
+    } //-- void setDebug( Boolean )
+
+    /**
+     * Set whether compilation and execution of unit and
+     * integration tests should be skipped.
+     * 
+     * @param skipTests
+     */
+    public void setSkipTests( Boolean skipTests )
+    {
+        this.skipTests = skipTests;
+    } //-- void setSkipTests( Boolean )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Configuration.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Configuration.java
new file mode 100644
index 0000000..f898bca
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Configuration.java
@@ -0,0 +1,343 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config;
+
+/**
+ * 
+ *         Root element of the configuration file.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Configuration
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field properties.
+     */
+    private java.util.Properties properties;
+
+    /**
+     * Field repositories.
+     */
+    private java.util.List<Repository> repositories;
+
+    /**
+     * 
+     *             This element contains basic XMvn settings.
+     *           
+     */
+    private BuildSettings buildSettings;
+
+    /**
+     * Field artifactManagement.
+     */
+    private java.util.List<PackagingRule> artifactManagement;
+
+    /**
+     * 
+     *             This element contains configuration of XMvn
+     * resolver.
+     *           
+     */
+    private ResolverSettings resolverSettings;
+
+    /**
+     * 
+     *             This element contains configuration of XMvn
+     * installer.
+     *           
+     */
+    private InstallerSettings installerSettings;
+
+    /**
+     * Field modelEncoding.
+     */
+    private String modelEncoding = "UTF-8";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addArtifactManagement.
+     * 
+     * @param packagingRule
+     */
+    public void addArtifactManagement( PackagingRule packagingRule )
+    {
+        getArtifactManagement().add( packagingRule );
+    } //-- void addArtifactManagement( PackagingRule )
+
+    /**
+     * Method addProperty.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addProperty( String key, String value )
+    {
+        getProperties().put( key, value );
+    } //-- void addProperty( String, String )
+
+    /**
+     * Method addRepository.
+     * 
+     * @param repository
+     */
+    public void addRepository( Repository repository )
+    {
+        getRepositories().add( repository );
+    } //-- void addRepository( Repository )
+
+    /**
+     * Method clone.
+     * 
+     * @return Configuration
+     */
+    public Configuration clone()
+    {
+        try
+        {
+            Configuration copy = (Configuration) super.clone();
+
+            if ( this.properties != null )
+            {
+                copy.properties = (java.util.Properties) this.properties.clone();
+            }
+
+            if ( this.repositories != null )
+            {
+                copy.repositories = new java.util.ArrayList<Repository>();
+                for ( Repository item : this.repositories )
+                {
+                    copy.repositories.add( ( (Repository) item).clone() );
+                }
+            }
+
+            if ( this.buildSettings != null )
+            {
+                copy.buildSettings = (BuildSettings) this.buildSettings.clone();
+            }
+
+            if ( this.artifactManagement != null )
+            {
+                copy.artifactManagement = new java.util.ArrayList<PackagingRule>();
+                for ( PackagingRule item : this.artifactManagement )
+                {
+                    copy.artifactManagement.add( ( (PackagingRule) item).clone() );
+                }
+            }
+
+            if ( this.resolverSettings != null )
+            {
+                copy.resolverSettings = (ResolverSettings) this.resolverSettings.clone();
+            }
+
+            if ( this.installerSettings != null )
+            {
+                copy.installerSettings = (InstallerSettings) this.installerSettings.clone();
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Configuration clone()
+
+    /**
+     * Method getArtifactManagement.
+     * 
+     * @return List
+     */
+    public java.util.List<PackagingRule> getArtifactManagement()
+    {
+        if ( this.artifactManagement == null )
+        {
+            this.artifactManagement = new java.util.ArrayList<PackagingRule>();
+        }
+
+        return this.artifactManagement;
+    } //-- java.util.List<PackagingRule> getArtifactManagement()
+
+    /**
+     * Get this element contains basic XMvn settings.
+     * 
+     * @return BuildSettings
+     */
+    public BuildSettings getBuildSettings()
+    {
+        return this.buildSettings;
+    } //-- BuildSettings getBuildSettings()
+
+    /**
+     * Get this element contains configuration of XMvn installer.
+     * 
+     * @return InstallerSettings
+     */
+    public InstallerSettings getInstallerSettings()
+    {
+        return this.installerSettings;
+    } //-- InstallerSettings getInstallerSettings()
+
+    /**
+     * Get the modelEncoding field.
+     * 
+     * @return String
+     */
+    public String getModelEncoding()
+    {
+        return this.modelEncoding;
+    } //-- String getModelEncoding()
+
+    /**
+     * Method getProperties.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getProperties()
+    {
+        if ( this.properties == null )
+        {
+            this.properties = new java.util.Properties();
+        }
+
+        return this.properties;
+    } //-- java.util.Properties getProperties()
+
+    /**
+     * Method getRepositories.
+     * 
+     * @return List
+     */
+    public java.util.List<Repository> getRepositories()
+    {
+        if ( this.repositories == null )
+        {
+            this.repositories = new java.util.ArrayList<Repository>();
+        }
+
+        return this.repositories;
+    } //-- java.util.List<Repository> getRepositories()
+
+    /**
+     * Get this element contains configuration of XMvn resolver.
+     * 
+     * @return ResolverSettings
+     */
+    public ResolverSettings getResolverSettings()
+    {
+        return this.resolverSettings;
+    } //-- ResolverSettings getResolverSettings()
+
+    /**
+     * Method removeArtifactManagement.
+     * 
+     * @param packagingRule
+     */
+    public void removeArtifactManagement( PackagingRule packagingRule )
+    {
+        getArtifactManagement().remove( packagingRule );
+    } //-- void removeArtifactManagement( PackagingRule )
+
+    /**
+     * Method removeRepository.
+     * 
+     * @param repository
+     */
+    public void removeRepository( Repository repository )
+    {
+        getRepositories().remove( repository );
+    } //-- void removeRepository( Repository )
+
+    /**
+     * Set this element configures how artifacts should be assigned
+     *             to individual packages.
+     * 
+     * @param artifactManagement
+     */
+    public void setArtifactManagement( java.util.List<PackagingRule> artifactManagement )
+    {
+        this.artifactManagement = artifactManagement;
+    } //-- void setArtifactManagement( java.util.List )
+
+    /**
+     * Set this element contains basic XMvn settings.
+     * 
+     * @param buildSettings
+     */
+    public void setBuildSettings( BuildSettings buildSettings )
+    {
+        this.buildSettings = buildSettings;
+    } //-- void setBuildSettings( BuildSettings )
+
+    /**
+     * Set this element contains configuration of XMvn installer.
+     * 
+     * @param installerSettings
+     */
+    public void setInstallerSettings( InstallerSettings installerSettings )
+    {
+        this.installerSettings = installerSettings;
+    } //-- void setInstallerSettings( InstallerSettings )
+
+    /**
+     * Set the modelEncoding field.
+     * 
+     * @param modelEncoding
+     */
+    public void setModelEncoding( String modelEncoding )
+    {
+        this.modelEncoding = modelEncoding;
+    } //-- void setModelEncoding( String )
+
+    /**
+     * Set this element lists system Java properties that should be
+     * set before XMvn build is started.
+     * 
+     * @param properties
+     */
+    public void setProperties( java.util.Properties properties )
+    {
+        this.properties = properties;
+    } //-- void setProperties( java.util.Properties )
+
+    /**
+     * Set list of repositories.  Repositories can be used by
+     *             resolvers as source of artifacts, by installers
+     * as target
+     *             where artifacts should be installed, or by any
+     * other
+     *             component.
+     * 
+     * @param repositories
+     */
+    public void setRepositories( java.util.List<Repository> repositories )
+    {
+        this.repositories = repositories;
+    } //-- void setRepositories( java.util.List )
+
+    /**
+     * Set this element contains configuration of XMvn resolver.
+     * 
+     * @param resolverSettings
+     */
+    public void setResolverSettings( ResolverSettings resolverSettings )
+    {
+        this.resolverSettings = resolverSettings;
+    } //-- void setResolverSettings( ResolverSettings )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/InstallerSettings.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/InstallerSettings.java
new file mode 100644
index 0000000..96d87b3
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/InstallerSettings.java
@@ -0,0 +1,108 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config;
+
+/**
+ * XMvn settings related to installation of artifacts.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class InstallerSettings
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Whether additional debugging information about
+     * artifact
+     *             installation should be printed.
+     *           
+     */
+    private Boolean debug;
+
+    /**
+     * 
+     *             Directory into which XMvn metadata files are be
+     * installed.
+     *           
+     */
+    private String metadataDir;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return InstallerSettings
+     */
+    public InstallerSettings clone()
+    {
+        try
+        {
+            InstallerSettings copy = (InstallerSettings) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- InstallerSettings clone()
+
+    /**
+     * Get directory into which XMvn metadata files are be
+     * installed.
+     * 
+     * @return String
+     */
+    public String getMetadataDir()
+    {
+        return this.metadataDir;
+    } //-- String getMetadataDir()
+
+    /**
+     * Get whether additional debugging information about artifact
+     *             installation should be printed.
+     * 
+     * @return Boolean
+     */
+    public Boolean isDebug()
+    {
+        return this.debug;
+    } //-- Boolean isDebug()
+
+    /**
+     * Set whether additional debugging information about artifact
+     *             installation should be printed.
+     * 
+     * @param debug
+     */
+    public void setDebug( Boolean debug )
+    {
+        this.debug = debug;
+    } //-- void setDebug( Boolean )
+
+    /**
+     * Set directory into which XMvn metadata files are be
+     * installed.
+     * 
+     * @param metadataDir
+     */
+    public void setMetadataDir( String metadataDir )
+    {
+        this.metadataDir = metadataDir;
+    } //-- void setMetadataDir( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/PackagingRule.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/PackagingRule.java
new file mode 100644
index 0000000..d40ab78
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/PackagingRule.java
@@ -0,0 +1,374 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config;
+
+/**
+ * Identification of Maven Artifact.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class PackagingRule
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Pattern specifying one or more Maven artifacts.
+     */
+    private Artifact artifactGlob;
+
+    /**
+     * Name of binary package into which artifacts are assigned.
+     */
+    private String targetPackage;
+
+    /**
+     * 
+     *             ID of repository into which artifacts are
+     * installed.
+     *           
+     */
+    private String targetRepository;
+
+    /**
+     * Field files.
+     */
+    private java.util.List<String> files;
+
+    /**
+     * Field versions.
+     */
+    private java.util.List<String> versions;
+
+    /**
+     * Field aliases.
+     */
+    private java.util.List<Artifact> aliases;
+
+    /**
+     * 
+     *             Whether this rule is optional.  Non-optional
+     * rules cause
+     *             build failure if they are not matched.
+     *           
+     */
+    private Boolean optional = Boolean.valueOf( false );
+
+    /**
+     * 
+     *             Whether any reactor artifact matches artifact
+     * glob pattern
+     *             for this rule.  Non-optional rules cause build
+     * failure if
+     *             they are not matched.
+     *           
+     */
+    private Boolean matched = Boolean.valueOf( false );
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addFile.
+     * 
+     * @param string
+     */
+    public void addFile( String string )
+    {
+        getFiles().add( string );
+    } //-- void addFile( String )
+
+    /**
+     * Method addVersion.
+     * 
+     * @param string
+     */
+    public void addVersion( String string )
+    {
+        getVersions().add( string );
+    } //-- void addVersion( String )
+
+    /**
+     * Method clone.
+     * 
+     * @return PackagingRule
+     */
+    public PackagingRule clone()
+    {
+        try
+        {
+            PackagingRule copy = (PackagingRule) super.clone();
+
+            if ( this.artifactGlob != null )
+            {
+                copy.artifactGlob = (Artifact) this.artifactGlob.clone();
+            }
+
+            if ( this.files != null )
+            {
+                copy.files = new java.util.ArrayList<String>();
+                copy.files.addAll( this.files );
+            }
+
+            if ( this.versions != null )
+            {
+                copy.versions = new java.util.ArrayList<String>();
+                copy.versions.addAll( this.versions );
+            }
+
+            if ( this.aliases != null )
+            {
+                copy.aliases = new java.util.ArrayList<Artifact>();
+                for ( Artifact item : this.aliases )
+                {
+                    copy.aliases.add( ( (Artifact) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- PackagingRule clone()
+
+    /**
+     * Method getAliases.
+     * 
+     * @return List
+     */
+    public java.util.List<Artifact> getAliases()
+    {
+        if ( this.aliases == null )
+        {
+            this.aliases = new java.util.ArrayList<Artifact>();
+        }
+
+        return this.aliases;
+    } //-- java.util.List<Artifact> getAliases()
+
+    /**
+     * Get pattern specifying one or more Maven artifacts.
+     * 
+     * @return Artifact
+     */
+    public Artifact getArtifactGlob()
+    {
+        return this.artifactGlob;
+    } //-- Artifact getArtifactGlob()
+
+    /**
+     * Method getFiles.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getFiles()
+    {
+        if ( this.files == null )
+        {
+            this.files = new java.util.ArrayList<String>();
+        }
+
+        return this.files;
+    } //-- java.util.List<String> getFiles()
+
+    /**
+     * Get name of binary package into which artifacts are
+     * assigned.
+     * 
+     * @return String
+     */
+    public String getTargetPackage()
+    {
+        return this.targetPackage;
+    } //-- String getTargetPackage()
+
+    /**
+     * Get iD of repository into which artifacts are installed.
+     * 
+     * @return String
+     */
+    public String getTargetRepository()
+    {
+        return this.targetRepository;
+    } //-- String getTargetRepository()
+
+    /**
+     * Method getVersions.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getVersions()
+    {
+        if ( this.versions == null )
+        {
+            this.versions = new java.util.ArrayList<String>();
+        }
+
+        return this.versions;
+    } //-- java.util.List<String> getVersions()
+
+    /**
+     * Get whether any reactor artifact matches artifact glob
+     * pattern
+     *             for this rule.  Non-optional rules cause build
+     * failure if
+     *             they are not matched.
+     * 
+     * @return Boolean
+     */
+    public Boolean isMatched()
+    {
+        return this.matched;
+    } //-- Boolean isMatched()
+
+    /**
+     * Get whether this rule is optional.  Non-optional rules cause
+     *             build failure if they are not matched.
+     * 
+     * @return Boolean
+     */
+    public Boolean isOptional()
+    {
+        return this.optional;
+    } //-- Boolean isOptional()
+
+    /**
+     * Method removeFile.
+     * 
+     * @param string
+     */
+    public void removeFile( String string )
+    {
+        getFiles().remove( string );
+    } //-- void removeFile( String )
+
+    /**
+     * Method removeVersion.
+     * 
+     * @param string
+     */
+    public void removeVersion( String string )
+    {
+        getVersions().remove( string );
+    } //-- void removeVersion( String )
+
+    /**
+     * Set alternative identifiers of artifacts.
+     * 
+     * @param aliases
+     */
+    public void setAliases( java.util.List<Artifact> aliases )
+    {
+        this.aliases = aliases;
+    } //-- void setAliases( java.util.List )
+
+    /**
+     * Set pattern specifying one or more Maven artifacts.
+     * 
+     * @param artifactGlob
+     */
+    public void setArtifactGlob( Artifact artifactGlob )
+    {
+        this.artifactGlob = artifactGlob;
+    } //-- void setArtifactGlob( Artifact )
+
+    /**
+     * Set files holding the artifact.
+     * 
+     * @param files
+     */
+    public void setFiles( java.util.List<String> files )
+    {
+        this.files = files;
+    } //-- void setFiles( java.util.List )
+
+    /**
+     * Set whether any reactor artifact matches artifact glob
+     * pattern
+     *             for this rule.  Non-optional rules cause build
+     * failure if
+     *             they are not matched.
+     * 
+     * @param matched
+     */
+    public void setMatched( Boolean matched )
+    {
+        this.matched = matched;
+    } //-- void setMatched( Boolean )
+
+    /**
+     * Set whether this rule is optional.  Non-optional rules cause
+     *             build failure if they are not matched.
+     * 
+     * @param optional
+     */
+    public void setOptional( Boolean optional )
+    {
+        this.optional = optional;
+    } //-- void setOptional( Boolean )
+
+    /**
+     * Set name of binary package into which artifacts are
+     * assigned.
+     * 
+     * @param targetPackage
+     */
+    public void setTargetPackage( String targetPackage )
+    {
+        this.targetPackage = targetPackage;
+    } //-- void setTargetPackage( String )
+
+    /**
+     * Set iD of repository into which artifacts are installed.
+     * 
+     * @param targetRepository
+     */
+    public void setTargetRepository( String targetRepository )
+    {
+        this.targetRepository = targetRepository;
+    } //-- void setTargetRepository( String )
+
+    /**
+     * Set compatibility versions of the artifact.
+     * 
+     * @param versions
+     */
+    public void setVersions( java.util.List<String> versions )
+    {
+        this.versions = versions;
+    } //-- void setVersions( java.util.List )
+
+    
+            
+    /**
+     * Add an alias.
+     * @param artifact alias to be added
+     */
+    public void addAlias( Artifact artifact )
+    {
+        getAliases().add( artifact );
+    }
+
+    /**
+     * Remove an alias.
+     * @param artifact alias to be removed
+     */
+    public void removeAlias( Artifact artifact )
+    {
+        getAliases().remove( artifact );
+    }
+            
+          
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Repository.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Repository.java
new file mode 100644
index 0000000..88a5374
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Repository.java
@@ -0,0 +1,308 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config;
+
+/**
+ * Artifact repository.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Repository
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Unique string identifying this repository.
+     */
+    private String id;
+
+    /**
+     * 
+     *             Role hint of Plexus component implementing the
+     * repository.
+     *           
+     */
+    private String type;
+
+    /**
+     * Field stereotypes.
+     */
+    private java.util.List<Stereotype> stereotypes;
+
+    /**
+     * Field properties.
+     */
+    private java.util.Properties properties;
+
+    /**
+     * 
+     *             Arbitrary XML used to configure structure of the
+     *             repository.  Configuration can be freely used by
+     * the
+     *             implementation, so their exact meaning depends
+     * on
+     *             repository type.  See documentation for
+     * repository types
+     *             to see the format of supported configuration (if
+     * any).
+     *           
+     */
+    private Object configuration;
+
+    /**
+     * 
+     *             A boolean expression describing which artifacts
+     * can be
+     *             stored in this repository.
+     *           
+     */
+    private Object filter;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addProperty.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addProperty( String key, String value )
+    {
+        getProperties().put( key, value );
+    } //-- void addProperty( String, String )
+
+    /**
+     * Method addStereotype.
+     * 
+     * @param stereotype
+     */
+    public void addStereotype( Stereotype stereotype )
+    {
+        getStereotypes().add( stereotype );
+    } //-- void addStereotype( Stereotype )
+
+    /**
+     * Method clone.
+     * 
+     * @return Repository
+     */
+    public Repository clone()
+    {
+        try
+        {
+            Repository copy = (Repository) super.clone();
+
+            if ( this.stereotypes != null )
+            {
+                copy.stereotypes = new java.util.ArrayList<Stereotype>();
+                for ( Stereotype item : this.stereotypes )
+                {
+                    copy.stereotypes.add( ( (Stereotype) item).clone() );
+                }
+            }
+
+            if ( this.properties != null )
+            {
+                copy.properties = (java.util.Properties) this.properties.clone();
+            }
+
+            if ( this.configuration != null )
+            {
+                copy.configuration = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.configuration );
+            }
+
+            if ( this.filter != null )
+            {
+                copy.filter = new org.codehaus.plexus.util.xml.Xpp3Dom( (org.codehaus.plexus.util.xml.Xpp3Dom) this.filter );
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Repository clone()
+
+    /**
+     * Get arbitrary XML used to configure structure of the
+     *             repository.  Configuration can be freely used by
+     * the
+     *             implementation, so their exact meaning depends
+     * on
+     *             repository type.  See documentation for
+     * repository types
+     *             to see the format of supported configuration (if
+     * any).
+     * 
+     * @return Object
+     */
+    public Object getConfiguration()
+    {
+        return this.configuration;
+    } //-- Object getConfiguration()
+
+    /**
+     * Get a boolean expression describing which artifacts can be
+     *             stored in this repository.
+     * 
+     * @return Object
+     */
+    public Object getFilter()
+    {
+        return this.filter;
+    } //-- Object getFilter()
+
+    /**
+     * Get unique string identifying this repository.
+     * 
+     * @return String
+     */
+    public String getId()
+    {
+        return this.id;
+    } //-- String getId()
+
+    /**
+     * Method getProperties.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getProperties()
+    {
+        if ( this.properties == null )
+        {
+            this.properties = new java.util.Properties();
+        }
+
+        return this.properties;
+    } //-- java.util.Properties getProperties()
+
+    /**
+     * Method getStereotypes.
+     * 
+     * @return List
+     */
+    public java.util.List<Stereotype> getStereotypes()
+    {
+        if ( this.stereotypes == null )
+        {
+            this.stereotypes = new java.util.ArrayList<Stereotype>();
+        }
+
+        return this.stereotypes;
+    } //-- java.util.List<Stereotype> getStereotypes()
+
+    /**
+     * Get role hint of Plexus component implementing the
+     * repository.
+     * 
+     * @return String
+     */
+    public String getType()
+    {
+        return this.type;
+    } //-- String getType()
+
+    /**
+     * Method removeStereotype.
+     * 
+     * @param stereotype
+     */
+    public void removeStereotype( Stereotype stereotype )
+    {
+        getStereotypes().remove( stereotype );
+    } //-- void removeStereotype( Stereotype )
+
+    /**
+     * Set arbitrary XML used to configure structure of the
+     *             repository.  Configuration can be freely used by
+     * the
+     *             implementation, so their exact meaning depends
+     * on
+     *             repository type.  See documentation for
+     * repository types
+     *             to see the format of supported configuration (if
+     * any).
+     * 
+     * @param configuration
+     */
+    public void setConfiguration( Object configuration )
+    {
+        this.configuration = configuration;
+    } //-- void setConfiguration( Object )
+
+    /**
+     * Set a boolean expression describing which artifacts can be
+     *             stored in this repository.
+     * 
+     * @param filter
+     */
+    public void setFilter( Object filter )
+    {
+        this.filter = filter;
+    } //-- void setFilter( Object )
+
+    /**
+     * Set unique string identifying this repository.
+     * 
+     * @param id
+     */
+    public void setId( String id )
+    {
+        this.id = id;
+    } //-- void setId( String )
+
+    /**
+     * Set properties associated with this repository.  Properties
+     *             can be freely used by the implementation, so
+     * their exact
+     *             meaning depends on repository type.  See
+     * documentation for
+     *             repository types to see list of supported
+     * properties.
+     * 
+     * @param properties
+     */
+    public void setProperties( java.util.Properties properties )
+    {
+        this.properties = properties;
+    } //-- void setProperties( java.util.Properties )
+
+    /**
+     * Set list of artifact types that can be stored in this
+     *             repository.  Empty list means that this
+     * repository can
+     *             store any artifact type.
+     * 
+     * @param stereotypes
+     */
+    public void setStereotypes( java.util.List<Stereotype> stereotypes )
+    {
+        this.stereotypes = stereotypes;
+    } //-- void setStereotypes( java.util.List )
+
+    /**
+     * Set role hint of Plexus component implementing the
+     * repository.
+     * 
+     * @param type
+     */
+    public void setType( String type )
+    {
+        this.type = type;
+    } //-- void setType( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/ResolverSettings.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/ResolverSettings.java
new file mode 100644
index 0000000..5d99b74
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/ResolverSettings.java
@@ -0,0 +1,310 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config;
+
+/**
+ * XMvn settings related to resolution of artifacts.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ResolverSettings
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Whether detailed debugging information about
+     * artifact
+     *             resolution process should be logged.
+     *           
+     */
+    private Boolean debug;
+
+    /**
+     * Field localRepositories.
+     */
+    private java.util.List<String> localRepositories;
+
+    /**
+     * Field metadataRepositories.
+     */
+    private java.util.List<String> metadataRepositories;
+
+    /**
+     * Field prefixes.
+     */
+    private java.util.List<String> prefixes;
+
+    /**
+     * Field blacklist.
+     */
+    private java.util.List<Artifact> blacklist;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addBlacklist.
+     * 
+     * @param artifact
+     */
+    public void addBlacklist( Artifact artifact )
+    {
+        getBlacklist().add( artifact );
+    } //-- void addBlacklist( Artifact )
+
+    /**
+     * Method addLocalRepository.
+     * 
+     * @param string
+     */
+    public void addLocalRepository( String string )
+    {
+        getLocalRepositories().add( string );
+    } //-- void addLocalRepository( String )
+
+    /**
+     * Method addMetadataRepository.
+     * 
+     * @param string
+     */
+    public void addMetadataRepository( String string )
+    {
+        getMetadataRepositories().add( string );
+    } //-- void addMetadataRepository( String )
+
+    /**
+     * Method addPrefix.
+     * 
+     * @param string
+     */
+    public void addPrefix( String string )
+    {
+        getPrefixes().add( string );
+    } //-- void addPrefix( String )
+
+    /**
+     * Method clone.
+     * 
+     * @return ResolverSettings
+     */
+    public ResolverSettings clone()
+    {
+        try
+        {
+            ResolverSettings copy = (ResolverSettings) super.clone();
+
+            if ( this.localRepositories != null )
+            {
+                copy.localRepositories = new java.util.ArrayList<String>();
+                copy.localRepositories.addAll( this.localRepositories );
+            }
+
+            if ( this.metadataRepositories != null )
+            {
+                copy.metadataRepositories = new java.util.ArrayList<String>();
+                copy.metadataRepositories.addAll( this.metadataRepositories );
+            }
+
+            if ( this.prefixes != null )
+            {
+                copy.prefixes = new java.util.ArrayList<String>();
+                copy.prefixes.addAll( this.prefixes );
+            }
+
+            if ( this.blacklist != null )
+            {
+                copy.blacklist = new java.util.ArrayList<Artifact>();
+                for ( Artifact item : this.blacklist )
+                {
+                    copy.blacklist.add( ( (Artifact) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ResolverSettings clone()
+
+    /**
+     * Method getBlacklist.
+     * 
+     * @return List
+     */
+    public java.util.List<Artifact> getBlacklist()
+    {
+        if ( this.blacklist == null )
+        {
+            this.blacklist = new java.util.ArrayList<Artifact>();
+        }
+
+        return this.blacklist;
+    } //-- java.util.List<Artifact> getBlacklist()
+
+    /**
+     * Method getLocalRepositories.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getLocalRepositories()
+    {
+        if ( this.localRepositories == null )
+        {
+            this.localRepositories = new java.util.ArrayList<String>();
+        }
+
+        return this.localRepositories;
+    } //-- java.util.List<String> getLocalRepositories()
+
+    /**
+     * Method getMetadataRepositories.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getMetadataRepositories()
+    {
+        if ( this.metadataRepositories == null )
+        {
+            this.metadataRepositories = new java.util.ArrayList<String>();
+        }
+
+        return this.metadataRepositories;
+    } //-- java.util.List<String> getMetadataRepositories()
+
+    /**
+     * Method getPrefixes.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getPrefixes()
+    {
+        if ( this.prefixes == null )
+        {
+            this.prefixes = new java.util.ArrayList<String>();
+        }
+
+        return this.prefixes;
+    } //-- java.util.List<String> getPrefixes()
+
+    /**
+     * Get whether detailed debugging information about artifact
+     *             resolution process should be logged.
+     * 
+     * @return Boolean
+     */
+    public Boolean isDebug()
+    {
+        return this.debug;
+    } //-- Boolean isDebug()
+
+    /**
+     * Method removeBlacklist.
+     * 
+     * @param artifact
+     */
+    public void removeBlacklist( Artifact artifact )
+    {
+        getBlacklist().remove( artifact );
+    } //-- void removeBlacklist( Artifact )
+
+    /**
+     * Method removeLocalRepository.
+     * 
+     * @param string
+     */
+    public void removeLocalRepository( String string )
+    {
+        getLocalRepositories().remove( string );
+    } //-- void removeLocalRepository( String )
+
+    /**
+     * Method removeMetadataRepository.
+     * 
+     * @param string
+     */
+    public void removeMetadataRepository( String string )
+    {
+        getMetadataRepositories().remove( string );
+    } //-- void removeMetadataRepository( String )
+
+    /**
+     * Method removePrefix.
+     * 
+     * @param string
+     */
+    public void removePrefix( String string )
+    {
+        getPrefixes().remove( string );
+    } //-- void removePrefix( String )
+
+    /**
+     * Set list of blacklisted artifacts which will not be
+     * resolved.
+     * 
+     * @param blacklist
+     */
+    public void setBlacklist( java.util.List<Artifact> blacklist )
+    {
+        this.blacklist = blacklist;
+    } //-- void setBlacklist( java.util.List )
+
+    /**
+     * Set whether detailed debugging information about artifact
+     *             resolution process should be logged.
+     * 
+     * @param debug
+     */
+    public void setDebug( Boolean debug )
+    {
+        this.debug = debug;
+    } //-- void setDebug( Boolean )
+
+    /**
+     * Set list of local repositories where XMvn will look for
+     * artifacts.
+     * 
+     * @param localRepositories
+     */
+    public void setLocalRepositories( java.util.List<String> localRepositories )
+    {
+        this.localRepositories = localRepositories;
+    } //-- void setLocalRepositories( java.util.List )
+
+    /**
+     * Set list of repositories where XMvn will look for metadata
+     *             files.
+     * 
+     * @param metadataRepositories
+     */
+    public void setMetadataRepositories( java.util.List<String> metadataRepositories )
+    {
+        this.metadataRepositories = metadataRepositories;
+    } //-- void setMetadataRepositories( java.util.List )
+
+    /**
+     * Set list of prefixes that XMvn resolver will prepend to
+     * system
+     *             repositories.
+     * 
+     * @param prefixes
+     */
+    public void setPrefixes( java.util.List<String> prefixes )
+    {
+        this.prefixes = prefixes;
+    } //-- void setPrefixes( java.util.List )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Stereotype.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Stereotype.java
new file mode 100644
index 0000000..0a1d79e
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/Stereotype.java
@@ -0,0 +1,122 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config;
+
+/**
+ * Stereotype of Maven artifact.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Stereotype
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Type ID of the stereotype.
+     */
+    private String type;
+
+    /**
+     * Extension of the artifact.
+     */
+    private String extension;
+
+    /**
+     * Classifier of the artifact.
+     */
+    private String classifier;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return Stereotype
+     */
+    public Stereotype clone()
+    {
+        try
+        {
+            Stereotype copy = (Stereotype) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Stereotype clone()
+
+    /**
+     * Get classifier of the artifact.
+     * 
+     * @return String
+     */
+    public String getClassifier()
+    {
+        return this.classifier;
+    } //-- String getClassifier()
+
+    /**
+     * Get extension of the artifact.
+     * 
+     * @return String
+     */
+    public String getExtension()
+    {
+        return this.extension;
+    } //-- String getExtension()
+
+    /**
+     * Get type ID of the stereotype.
+     * 
+     * @return String
+     */
+    public String getType()
+    {
+        return this.type;
+    } //-- String getType()
+
+    /**
+     * Set classifier of the artifact.
+     * 
+     * @param classifier
+     */
+    public void setClassifier( String classifier )
+    {
+        this.classifier = classifier;
+    } //-- void setClassifier( String )
+
+    /**
+     * Set extension of the artifact.
+     * 
+     * @param extension
+     */
+    public void setExtension( String extension )
+    {
+        this.extension = extension;
+    } //-- void setExtension( String )
+
+    /**
+     * Set type ID of the stereotype.
+     * 
+     * @param type
+     */
+    public void setType( String type )
+    {
+        this.type = type;
+    } //-- void setType( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/ConfigurationStaxReader.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/ConfigurationStaxReader.java
new file mode 100644
index 0000000..1b52cab
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/ConfigurationStaxReader.java
@@ -0,0 +1,1139 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config.io.stax;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.ByteArrayInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.text.DateFormat;
+import java.text.ParsePosition;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.xml.stream.*;
+import org.codehaus.plexus.util.xml.Xpp3Dom;
+import org.fedoraproject.xmvn.config.Artifact;
+import org.fedoraproject.xmvn.config.BuildSettings;
+import org.fedoraproject.xmvn.config.Configuration;
+import org.fedoraproject.xmvn.config.InstallerSettings;
+import org.fedoraproject.xmvn.config.PackagingRule;
+import org.fedoraproject.xmvn.config.Repository;
+import org.fedoraproject.xmvn.config.ResolverSettings;
+import org.fedoraproject.xmvn.config.Stereotype;
+
+/**
+ * Class ConfigurationStaxReader.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ConfigurationStaxReader
+{
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method read.
+     * 
+     * @param reader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Configuration
+     */
+    public Configuration read( Reader reader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        XMLStreamReader xmlStreamReader = XMLInputFactory.newInstance().createXMLStreamReader( reader );
+
+        return read( xmlStreamReader, strict );
+    } //-- Configuration read( Reader, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param reader
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Configuration
+     */
+    public Configuration read( Reader reader )
+        throws IOException, XMLStreamException
+    {
+        return read( reader, true );
+    } //-- Configuration read( Reader )
+
+    /**
+     * Method read.
+     * 
+     * @param stream
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Configuration
+     */
+    public Configuration read( InputStream stream, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        XMLStreamReader xmlStreamReader = XMLInputFactory.newInstance().createXMLStreamReader( stream );
+
+        return read( xmlStreamReader, strict );
+    } //-- Configuration read( InputStream, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param stream
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Configuration
+     */
+    public Configuration read( InputStream stream )
+        throws IOException, XMLStreamException
+    {
+        return read( stream, true );
+    } //-- Configuration read( InputStream )
+
+    /**
+     * Method read.
+     * 
+     * @param filePath
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Configuration
+     */
+    public Configuration read( String filePath, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        java.io.File file = new java.io.File( filePath );
+        XMLStreamReader xmlStreamReader = XMLInputFactory.newInstance().createXMLStreamReader( file.toURI().toURL().toExternalForm(), new FileInputStream( file ) );
+
+        return read( xmlStreamReader, strict );
+    } //-- Configuration read( String, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param filePath
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Configuration
+     */
+    public Configuration read( String filePath )
+        throws IOException, XMLStreamException
+    {
+        return read( filePath, true );
+    } //-- Configuration read( String )
+
+    /**
+     * Method buildDom.
+     * 
+     * @param xmlStreamReader
+     * @param trim
+     * @throws XMLStreamException
+     * @return Xpp3Dom
+     */
+    private Xpp3Dom buildDom( XMLStreamReader xmlStreamReader, boolean trim )
+        throws XMLStreamException
+    {
+        java.util.Stack elements = new java.util.Stack();
+        java.util.Stack values = new java.util.Stack();
+        int eventType = xmlStreamReader.getEventType();
+        boolean spacePreserve = false;
+        while ( xmlStreamReader.hasNext() )
+        {
+            if ( eventType == XMLStreamConstants.START_ELEMENT )
+            {
+                spacePreserve = false;
+                String rawName = xmlStreamReader.getLocalName();
+                Xpp3Dom element = new Xpp3Dom( rawName );
+                if ( !elements.empty() )
+                {
+                    Xpp3Dom parent = (Xpp3Dom) elements.peek();
+                    parent.addChild( element );
+                }
+                elements.push( element );
+                if ( xmlStreamReader.isEndElement() )
+                {
+                    values.push( null );
+                }
+                else
+                {
+                    values.push( new StringBuffer() );
+                }
+                int attributesSize = xmlStreamReader.getAttributeCount();
+                for ( int i = 0; i < attributesSize; i++ )
+                {
+                    String name = xmlStreamReader.getAttributeLocalName( i );
+                    String value = xmlStreamReader.getAttributeValue( i );
+                    element.setAttribute( name, value );
+                    spacePreserve = spacePreserve || ( "xml".equals( xmlStreamReader.getAttributePrefix( i ) ) && "space".equals( name ) && "preserve".equals( value ) );
+                }
+            }
+            else if ( eventType == XMLStreamConstants.CHARACTERS )
+            {
+                StringBuffer valueBuffer = (StringBuffer) values.peek();
+                String text = xmlStreamReader.getText();
+                if ( trim && !spacePreserve )
+                {
+                    text = text.trim();
+                }
+                valueBuffer.append( text );
+            }
+            else if ( eventType == XMLStreamConstants.END_ELEMENT )
+            {
+                Xpp3Dom element = (Xpp3Dom) elements.pop();
+                // this Object could be null if it is a singleton tag
+                Object accumulatedValue = values.pop();
+                if ( element.getChildCount() == 0 )
+                {
+                    element.setValue( ( accumulatedValue == null ) ? null : accumulatedValue.toString() );
+                }
+                if ( values.empty() )
+                {
+                    return element;
+                }
+            }
+            eventType = xmlStreamReader.next();
+        }
+        throw new IllegalStateException( "End of document found before returning to 0 depth" );
+    } //-- Xpp3Dom buildDom( XMLStreamReader, boolean )
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param xmlStreamReader
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XMLStreamException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XMLStreamReader xmlStreamReader, String tagName, String alias, java.util.Set parsed )
+        throws XMLStreamException
+    {
+        if ( !( xmlStreamReader.getLocalName().equals( tagName ) || xmlStreamReader.getLocalName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XMLStreamException( "Duplicated tag: '" + tagName + "'", xmlStreamReader.getLocation() );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XMLStreamReader, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws XMLStreamException
+     */
+    private void checkUnknownElement( XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( strict )
+        {
+            throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+        }
+        int unrecognizedTagCount = 1;
+        while( unrecognizedTagCount != 0 )
+        {
+            xmlStreamReader.next();
+            if ( xmlStreamReader.getEventType() == XMLStreamConstants.START_ELEMENT )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( xmlStreamReader.getEventType() == XMLStreamConstants.END_ELEMENT )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XMLStreamReader, boolean )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XMLStreamReader xmlStreamReader )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XMLStreamReader )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a byte but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XMLStreamReader xmlStreamReader )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XMLStreamReader )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param xmlStreamReader
+     * @param dateFormat
+     * @param attribute
+     * @throws XMLStreamException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XMLStreamReader xmlStreamReader )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XMLStreamException( e.getMessage(), xmlStreamReader.getLocation(), e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XMLStreamException( e.getMessage(), xmlStreamReader.getLocation(), e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XMLStreamReader )
+
+    /**
+     * Method getDefaultValue.
+     * 
+     * @param s
+     * @param v
+     * @return String
+     */
+    private String getDefaultValue( String s, String v )
+    {
+        if ( s == null )
+        {
+            s = v;
+        }
+        return s;
+    } //-- String getDefaultValue( String, String )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a floating point number but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a floating point number but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be an integer but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a long integer but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XMLStreamException( "Missing required value for attribute '" + attribute + "'", xmlStreamReader.getLocation() );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a short integer but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param xmlStreamReader
+     * @throws XMLStreamException
+     * @return int
+     */
+    private int nextTag( XMLStreamReader xmlStreamReader )
+        throws XMLStreamException
+    {
+        while ( true )
+        {
+            int eventType = xmlStreamReader.next();
+            switch ( eventType )
+            {
+                case XMLStreamConstants.CHARACTERS:
+                case XMLStreamConstants.CDATA:
+                case XMLStreamConstants.SPACE:
+                case XMLStreamConstants.PROCESSING_INSTRUCTION:
+                case XMLStreamConstants.COMMENT:
+                    break;
+                case XMLStreamConstants.START_ELEMENT:
+                case XMLStreamConstants.END_ELEMENT:
+                    return eventType;
+                default:
+                    throw new XMLStreamException( "expected start or end tag", xmlStreamReader.getLocation() );
+            }
+        }
+    } //-- int nextTag( XMLStreamReader )
+
+    /**
+     * Method parseArtifact.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Artifact
+     */
+    private Artifact parseArtifact( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        Artifact artifact = new Artifact();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "groupId", null, parsed ) )
+            {
+                artifact.setGroupId( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "artifactId", null, parsed ) )
+            {
+                artifact.setArtifactId( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "version", null, parsed ) )
+            {
+                artifact.setVersion( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "classifier", null, parsed ) )
+            {
+                artifact.setClassifier( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "stereotype", null, parsed ) )
+            {
+                artifact.setStereotype( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "extension", null, parsed ) )
+            {
+                artifact.setExtension( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return artifact;
+    } //-- Artifact parseArtifact( XMLStreamReader, boolean )
+
+    /**
+     * Method parseBuildSettings.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return BuildSettings
+     */
+    private BuildSettings parseBuildSettings( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        BuildSettings buildSettings = new BuildSettings();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "debug", null, parsed ) )
+            {
+                buildSettings.setDebug( getBooleanValue( getTrimmedValue( xmlStreamReader.getElementText() ), "debug", xmlStreamReader ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "skipTests", null, parsed ) )
+            {
+                buildSettings.setSkipTests( getBooleanValue( getTrimmedValue( xmlStreamReader.getElementText() ), "skipTests", xmlStreamReader ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "compilerSource", null, parsed ) )
+            {
+                buildSettings.setCompilerSource( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return buildSettings;
+    } //-- BuildSettings parseBuildSettings( XMLStreamReader, boolean )
+
+    /**
+     * Method parseConfiguration.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Configuration
+     */
+    private Configuration parseConfiguration( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        Configuration configuration = new Configuration();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "properties", null, parsed ) )
+            {
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    String key = xmlStreamReader.getLocalName();
+                    String value = xmlStreamReader.getElementText().trim();
+                    configuration.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "repositories", null, parsed ) )
+            {
+                java.util.List repositories = new java.util.ArrayList/*<Repository>*/();
+                configuration.setRepositories( repositories );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "repository".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        configuration.addRepository( parseRepository( xmlStreamReader, strict ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "buildSettings", null, parsed ) )
+            {
+                configuration.setBuildSettings( parseBuildSettings( xmlStreamReader, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "artifactManagement", null, parsed ) )
+            {
+                java.util.List artifactManagement = new java.util.ArrayList/*<PackagingRule>*/();
+                configuration.setArtifactManagement( artifactManagement );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "rule".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        configuration.addArtifactManagement( parsePackagingRule( xmlStreamReader, strict ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "resolverSettings", null, parsed ) )
+            {
+                configuration.setResolverSettings( parseResolverSettings( xmlStreamReader, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "installerSettings", null, parsed ) )
+            {
+                configuration.setInstallerSettings( parseInstallerSettings( xmlStreamReader, strict ) );
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return configuration;
+    } //-- Configuration parseConfiguration( XMLStreamReader, boolean )
+
+    /**
+     * Method parseInstallerSettings.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return InstallerSettings
+     */
+    private InstallerSettings parseInstallerSettings( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        InstallerSettings installerSettings = new InstallerSettings();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "debug", null, parsed ) )
+            {
+                installerSettings.setDebug( getBooleanValue( getTrimmedValue( xmlStreamReader.getElementText() ), "debug", xmlStreamReader ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "metadataDir", null, parsed ) )
+            {
+                installerSettings.setMetadataDir( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return installerSettings;
+    } //-- InstallerSettings parseInstallerSettings( XMLStreamReader, boolean )
+
+    /**
+     * Method parsePackagingRule.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return PackagingRule
+     */
+    private PackagingRule parsePackagingRule( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        PackagingRule packagingRule = new PackagingRule();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "artifactGlob", null, parsed ) )
+            {
+                packagingRule.setArtifactGlob( parseArtifact( xmlStreamReader, strict ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "targetPackage", null, parsed ) )
+            {
+                packagingRule.setTargetPackage( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "targetRepository", null, parsed ) )
+            {
+                packagingRule.setTargetRepository( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "files", null, parsed ) )
+            {
+                java.util.List files = new java.util.ArrayList/*<String>*/();
+                packagingRule.setFiles( files );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "file".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        files.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "versions", null, parsed ) )
+            {
+                java.util.List versions = new java.util.ArrayList/*<String>*/();
+                packagingRule.setVersions( versions );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "version".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        versions.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "aliases", null, parsed ) )
+            {
+                java.util.List aliases = new java.util.ArrayList/*<Artifact>*/();
+                packagingRule.setAliases( aliases );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "alias".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        aliases.add( parseArtifact( xmlStreamReader, strict ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "optional", null, parsed ) )
+            {
+                packagingRule.setOptional( getBooleanValue( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "false" ) ), "optional", xmlStreamReader ) );
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return packagingRule;
+    } //-- PackagingRule parsePackagingRule( XMLStreamReader, boolean )
+
+    /**
+     * Method parseRepository.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Repository
+     */
+    private Repository parseRepository( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        Repository repository = new Repository();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "id", null, parsed ) )
+            {
+                repository.setId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "type", null, parsed ) )
+            {
+                repository.setType( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "stereotypes", null, parsed ) )
+            {
+                java.util.List stereotypes = new java.util.ArrayList/*<Stereotype>*/();
+                repository.setStereotypes( stereotypes );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "stereotype".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        repository.addStereotype( parseStereotype( xmlStreamReader, strict ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "properties", null, parsed ) )
+            {
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    String key = xmlStreamReader.getLocalName();
+                    String value = xmlStreamReader.getElementText().trim();
+                    repository.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "configuration", null, parsed ) )
+            {
+                repository.setConfiguration( buildDom( xmlStreamReader, true ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "filter", null, parsed ) )
+            {
+                repository.setFilter( buildDom( xmlStreamReader, true ) );
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return repository;
+    } //-- Repository parseRepository( XMLStreamReader, boolean )
+
+    /**
+     * Method parseResolverSettings.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return ResolverSettings
+     */
+    private ResolverSettings parseResolverSettings( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        ResolverSettings resolverSettings = new ResolverSettings();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "debug", null, parsed ) )
+            {
+                resolverSettings.setDebug( getBooleanValue( getTrimmedValue( xmlStreamReader.getElementText() ), "debug", xmlStreamReader ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "localRepositories", null, parsed ) )
+            {
+                java.util.List localRepositories = new java.util.ArrayList/*<String>*/();
+                resolverSettings.setLocalRepositories( localRepositories );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "repository".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        localRepositories.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "metadataRepositories", null, parsed ) )
+            {
+                java.util.List metadataRepositories = new java.util.ArrayList/*<String>*/();
+                resolverSettings.setMetadataRepositories( metadataRepositories );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "repository".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        metadataRepositories.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "prefixes", null, parsed ) )
+            {
+                java.util.List prefixes = new java.util.ArrayList/*<String>*/();
+                resolverSettings.setPrefixes( prefixes );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "prefix".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        prefixes.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "blacklist", null, parsed ) )
+            {
+                java.util.List blacklist = new java.util.ArrayList/*<Artifact>*/();
+                resolverSettings.setBlacklist( blacklist );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "artifact".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        resolverSettings.addBlacklist( parseArtifact( xmlStreamReader, strict ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return resolverSettings;
+    } //-- ResolverSettings parseResolverSettings( XMLStreamReader, boolean )
+
+    /**
+     * Method parseStereotype.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Stereotype
+     */
+    private Stereotype parseStereotype( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        Stereotype stereotype = new Stereotype();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "type", null, parsed ) )
+            {
+                stereotype.setType( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "extension", null, parsed ) )
+            {
+                stereotype.setExtension( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "classifier", null, parsed ) )
+            {
+                stereotype.setClassifier( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return stereotype;
+    } //-- Stereotype parseStereotype( XMLStreamReader, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Configuration
+     */
+    private Configuration read( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        int eventType = xmlStreamReader.getEventType();
+        String encoding = null;
+        while ( eventType != XMLStreamConstants.END_DOCUMENT )
+        {
+            if ( eventType == XMLStreamConstants.START_DOCUMENT )
+            {
+                encoding = xmlStreamReader.getCharacterEncodingScheme();
+            }
+            if ( eventType == XMLStreamConstants.START_ELEMENT )
+            {
+                if ( strict && ! "configuration".equals( xmlStreamReader.getLocalName() ) )
+                {
+                    throw new XMLStreamException( "Expected root element 'configuration' but found '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation(), null );
+                }
+                Configuration configuration = parseConfiguration( xmlStreamReader, strict );
+                configuration.setModelEncoding( encoding );
+                resolveReferences( configuration );
+                return configuration;
+            }
+            eventType = xmlStreamReader.next();
+        }
+        throw new XMLStreamException( "Expected root element 'configuration' but found no element at all: invalid XML document", xmlStreamReader.getLocation(), null );
+    } //-- Configuration read( XMLStreamReader, boolean )
+
+    /**
+     * Method resolveReferences.
+     * 
+     * @param value
+     */
+    private void resolveReferences( Configuration value )
+    {
+        java.util.Map refs;
+    } //-- void resolveReferences( Configuration )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/ConfigurationStaxWriter.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/ConfigurationStaxWriter.java
new file mode 100644
index 0000000..9f870f9
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/ConfigurationStaxWriter.java
@@ -0,0 +1,597 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config.io.stax;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.text.DateFormat;
+import java.util.Iterator;
+import java.util.Locale;
+import java.util.jar.Manifest;
+import javax.xml.stream.*;
+import org.codehaus.plexus.util.xml.Xpp3Dom;
+import org.fedoraproject.xmvn.config.Artifact;
+import org.fedoraproject.xmvn.config.BuildSettings;
+import org.fedoraproject.xmvn.config.Configuration;
+import org.fedoraproject.xmvn.config.InstallerSettings;
+import org.fedoraproject.xmvn.config.PackagingRule;
+import org.fedoraproject.xmvn.config.Repository;
+import org.fedoraproject.xmvn.config.ResolverSettings;
+import org.fedoraproject.xmvn.config.Stereotype;
+
+/**
+ * Class ConfigurationStaxWriter.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ConfigurationStaxWriter
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field curId.
+     */
+    private int curId;
+
+    /**
+     * Field idMap.
+     */
+    private java.util.Map idMap;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public ConfigurationStaxWriter()
+    {
+        idMap = new java.util.HashMap();
+    } //-- org.fedoraproject.xmvn.config.io.stax.ConfigurationStaxWriter()
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method write.
+     * 
+     * @param writer
+     * @param configuration
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    public void write( Writer writer, Configuration configuration )
+        throws java.io.IOException, XMLStreamException
+    {
+        XMLOutputFactory factory = XMLOutputFactory.newInstance();
+        boolean supportWindowsLineEndings = false;
+        if ( factory.isPropertySupported( "com.ctc.wstx.outputEscapeCr" ) )
+        {
+            factory.setProperty( "com.ctc.wstx.outputEscapeCr", Boolean.FALSE );
+            supportWindowsLineEndings = true;
+        }
+        if ( factory.isPropertySupported( "org.codehaus.stax2.automaticEmptyElements" ) )
+        {
+            factory.setProperty( "org.codehaus.stax2.automaticEmptyElements", Boolean.FALSE );
+        }
+        IndentingXMLStreamWriter serializer = new IndentingXMLStreamWriter( factory.createXMLStreamWriter( writer ) );
+        if ( supportWindowsLineEndings )
+        {
+            serializer.setNewLine( serializer.getLineSeparator() );
+        }
+        serializer.writeStartDocument( configuration.getModelEncoding(), "1.0" );
+        writeConfiguration( configuration, "configuration", serializer );
+        serializer.writeEndDocument();
+    } //-- void write( Writer, Configuration )
+
+    /**
+     * Method write.
+     * 
+     * @param stream
+     * @param configuration
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    public void write( OutputStream stream, Configuration configuration )
+        throws java.io.IOException, XMLStreamException
+    {
+        XMLOutputFactory factory = XMLOutputFactory.newInstance();
+        boolean supportWindowsLineEndings = false;
+        if ( factory.isPropertySupported( "com.ctc.wstx.outputEscapeCr" ) )
+        {
+            factory.setProperty( "com.ctc.wstx.outputEscapeCr", Boolean.FALSE );
+            supportWindowsLineEndings = true;
+        }
+        if ( factory.isPropertySupported( "org.codehaus.stax2.automaticEmptyElements" ) )
+        {
+            factory.setProperty( "org.codehaus.stax2.automaticEmptyElements", Boolean.FALSE );
+        }
+        IndentingXMLStreamWriter serializer = new IndentingXMLStreamWriter( factory.createXMLStreamWriter( stream, configuration.getModelEncoding() ) );
+        if ( supportWindowsLineEndings )
+        {
+            serializer.setNewLine( serializer.getLineSeparator() );
+        }
+        serializer.writeStartDocument( configuration.getModelEncoding(), "1.0" );
+        writeConfiguration( configuration, "configuration", serializer );
+        serializer.writeEndDocument();
+    } //-- void write( OutputStream, Configuration )
+
+    /**
+     * Method writeArtifact.
+     * 
+     * @param artifact
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeArtifact( Artifact artifact, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( artifact != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( ( artifact.getGroupId() != null ) && !artifact.getGroupId().equals( "" ) )
+            {
+                serializer.writeStartElement( "groupId" );
+                serializer.writeCharacters( artifact.getGroupId() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifact.getArtifactId() != null ) && !artifact.getArtifactId().equals( "" ) )
+            {
+                serializer.writeStartElement( "artifactId" );
+                serializer.writeCharacters( artifact.getArtifactId() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifact.getVersion() != null ) && !artifact.getVersion().equals( "" ) )
+            {
+                serializer.writeStartElement( "version" );
+                serializer.writeCharacters( artifact.getVersion() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifact.getClassifier() != null ) && !artifact.getClassifier().equals( "" ) )
+            {
+                serializer.writeStartElement( "classifier" );
+                serializer.writeCharacters( artifact.getClassifier() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifact.getStereotype() != null ) && !artifact.getStereotype().equals( "" ) )
+            {
+                serializer.writeStartElement( "stereotype" );
+                serializer.writeCharacters( artifact.getStereotype() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifact.getExtension() != null ) && !artifact.getExtension().equals( "" ) )
+            {
+                serializer.writeStartElement( "extension" );
+                serializer.writeCharacters( artifact.getExtension() );
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeArtifact( Artifact, String, XMLStreamWriter )
+
+    /**
+     * Method writeBuildSettings.
+     * 
+     * @param buildSettings
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeBuildSettings( BuildSettings buildSettings, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( buildSettings != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( buildSettings.isDebug() != null )
+            {
+                serializer.writeStartElement( "debug" );
+                serializer.writeCharacters( String.valueOf( buildSettings.isDebug() ) );
+                serializer.writeEndElement();
+            }
+            if ( buildSettings.isSkipTests() != null )
+            {
+                serializer.writeStartElement( "skipTests" );
+                serializer.writeCharacters( String.valueOf( buildSettings.isSkipTests() ) );
+                serializer.writeEndElement();
+            }
+            if ( buildSettings.getCompilerSource() != null )
+            {
+                serializer.writeStartElement( "compilerSource" );
+                serializer.writeCharacters( buildSettings.getCompilerSource() );
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeBuildSettings( BuildSettings, String, XMLStreamWriter )
+
+    /**
+     * Method writeConfiguration.
+     * 
+     * @param configuration
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeConfiguration( Configuration configuration, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( configuration != null )
+        {
+            serializer.setDefaultNamespace( "http://fedorahosted.org/xmvn/CONFIG/2.0.0" );
+            serializer.writeStartElement( tagName );
+            serializer.writeDefaultNamespace( "http://fedorahosted.org/xmvn/CONFIG/2.0.0" );
+            if ( ( configuration.getProperties() != null ) && ( configuration.getProperties().size() > 0 ) )
+            {
+                serializer.writeStartElement( "properties" );
+                for ( Iterator iter = configuration.getProperties().keySet().iterator(); iter.hasNext(); )
+                {
+                    String key = (String) iter.next();
+                    String value = (String) configuration.getProperties().get( key );
+                    serializer.writeStartElement( "" + key + "" );
+                    serializer.writeCharacters( value );
+                    serializer.writeEndElement();
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( configuration.getRepositories() != null ) && ( configuration.getRepositories().size() > 0 ) )
+            {
+                serializer.writeStartElement( "repositories" );
+                for ( Iterator iter = configuration.getRepositories().iterator(); iter.hasNext(); )
+                {
+                    Repository o = (Repository) iter.next();
+                    writeRepository( o, "repository", serializer );
+                }
+                serializer.writeEndElement();
+            }
+            if ( configuration.getBuildSettings() != null )
+            {
+                writeBuildSettings( (BuildSettings) configuration.getBuildSettings(), "buildSettings", serializer );
+            }
+            if ( ( configuration.getArtifactManagement() != null ) && ( configuration.getArtifactManagement().size() > 0 ) )
+            {
+                serializer.writeStartElement( "artifactManagement" );
+                for ( Iterator iter = configuration.getArtifactManagement().iterator(); iter.hasNext(); )
+                {
+                    PackagingRule o = (PackagingRule) iter.next();
+                    writePackagingRule( o, "rule", serializer );
+                }
+                serializer.writeEndElement();
+            }
+            if ( configuration.getResolverSettings() != null )
+            {
+                writeResolverSettings( (ResolverSettings) configuration.getResolverSettings(), "resolverSettings", serializer );
+            }
+            if ( configuration.getInstallerSettings() != null )
+            {
+                writeInstallerSettings( (InstallerSettings) configuration.getInstallerSettings(), "installerSettings", serializer );
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeConfiguration( Configuration, String, XMLStreamWriter )
+
+    /**
+     * Method writeDom.
+     * 
+     * @param dom
+     * @param serializer
+     * @throws XMLStreamException
+     */
+    private void writeDom( Xpp3Dom dom, XMLStreamWriter serializer )
+        throws XMLStreamException
+    {
+        serializer.writeStartElement( dom.getName() );
+        String[] attributeNames = dom.getAttributeNames();
+        for ( int i = 0; i < attributeNames.length; i++ )
+        {
+            String attributeName = attributeNames[i];
+            serializer.writeAttribute( attributeName, dom.getAttribute( attributeName ) );
+        }
+        Xpp3Dom[] children = dom.getChildren();
+        for ( int i = 0; i < children.length; i++ )
+        {
+            writeDom( children[i], serializer );
+        }
+        String value = dom.getValue();
+        if ( value != null )
+        {
+            serializer.writeCharacters( value );
+        }
+        serializer.writeEndElement();
+    } //-- void writeDom( Xpp3Dom, XMLStreamWriter )
+
+    /**
+     * Method writeInstallerSettings.
+     * 
+     * @param installerSettings
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeInstallerSettings( InstallerSettings installerSettings, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( installerSettings != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( installerSettings.isDebug() != null )
+            {
+                serializer.writeStartElement( "debug" );
+                serializer.writeCharacters( String.valueOf( installerSettings.isDebug() ) );
+                serializer.writeEndElement();
+            }
+            if ( installerSettings.getMetadataDir() != null )
+            {
+                serializer.writeStartElement( "metadataDir" );
+                serializer.writeCharacters( installerSettings.getMetadataDir() );
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeInstallerSettings( InstallerSettings, String, XMLStreamWriter )
+
+    /**
+     * Method writePackagingRule.
+     * 
+     * @param packagingRule
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writePackagingRule( PackagingRule packagingRule, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( packagingRule != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( packagingRule.getArtifactGlob() != null )
+            {
+                writeArtifact( (Artifact) packagingRule.getArtifactGlob(), "artifactGlob", serializer );
+            }
+            if ( packagingRule.getTargetPackage() != null )
+            {
+                serializer.writeStartElement( "targetPackage" );
+                serializer.writeCharacters( packagingRule.getTargetPackage() );
+                serializer.writeEndElement();
+            }
+            if ( packagingRule.getTargetRepository() != null )
+            {
+                serializer.writeStartElement( "targetRepository" );
+                serializer.writeCharacters( packagingRule.getTargetRepository() );
+                serializer.writeEndElement();
+            }
+            if ( ( packagingRule.getFiles() != null ) && ( packagingRule.getFiles().size() > 0 ) )
+            {
+                serializer.writeStartElement( "files" );
+                for ( Iterator iter = packagingRule.getFiles().iterator(); iter.hasNext(); )
+                {
+                    String file = (String) iter.next();
+                    serializer.writeStartElement( "file" );
+                    serializer.writeCharacters( file );
+                    serializer.writeEndElement();
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( packagingRule.getVersions() != null ) && ( packagingRule.getVersions().size() > 0 ) )
+            {
+                serializer.writeStartElement( "versions" );
+                for ( Iterator iter = packagingRule.getVersions().iterator(); iter.hasNext(); )
+                {
+                    String version = (String) iter.next();
+                    serializer.writeStartElement( "version" );
+                    serializer.writeCharacters( version );
+                    serializer.writeEndElement();
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( packagingRule.getAliases() != null ) && ( packagingRule.getAliases().size() > 0 ) )
+            {
+                serializer.writeStartElement( "aliases" );
+                for ( Iterator iter = packagingRule.getAliases().iterator(); iter.hasNext(); )
+                {
+                    Artifact o = (Artifact) iter.next();
+                    writeArtifact( o, "alias", serializer );
+                }
+                serializer.writeEndElement();
+            }
+            if ( packagingRule.isOptional() != null )
+            {
+                serializer.writeStartElement( "optional" );
+                serializer.writeCharacters( String.valueOf( packagingRule.isOptional() ) );
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writePackagingRule( PackagingRule, String, XMLStreamWriter )
+
+    /**
+     * Method writeRepository.
+     * 
+     * @param repository
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeRepository( Repository repository, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( repository != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( repository.getId() != null )
+            {
+                serializer.writeStartElement( "id" );
+                serializer.writeCharacters( repository.getId() );
+                serializer.writeEndElement();
+            }
+            if ( repository.getType() != null )
+            {
+                serializer.writeStartElement( "type" );
+                serializer.writeCharacters( repository.getType() );
+                serializer.writeEndElement();
+            }
+            if ( ( repository.getStereotypes() != null ) && ( repository.getStereotypes().size() > 0 ) )
+            {
+                serializer.writeStartElement( "stereotypes" );
+                for ( Iterator iter = repository.getStereotypes().iterator(); iter.hasNext(); )
+                {
+                    Stereotype o = (Stereotype) iter.next();
+                    writeStereotype( o, "stereotype", serializer );
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( repository.getProperties() != null ) && ( repository.getProperties().size() > 0 ) )
+            {
+                serializer.writeStartElement( "properties" );
+                for ( Iterator iter = repository.getProperties().keySet().iterator(); iter.hasNext(); )
+                {
+                    String key = (String) iter.next();
+                    String value = (String) repository.getProperties().get( key );
+                    serializer.writeStartElement( "" + key + "" );
+                    serializer.writeCharacters( value );
+                    serializer.writeEndElement();
+                }
+                serializer.writeEndElement();
+            }
+            if ( repository.getConfiguration() != null )
+            {
+                writeDom( (Xpp3Dom) repository.getConfiguration(), serializer );
+            }
+            if ( repository.getFilter() != null )
+            {
+                writeDom( (Xpp3Dom) repository.getFilter(), serializer );
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeRepository( Repository, String, XMLStreamWriter )
+
+    /**
+     * Method writeResolverSettings.
+     * 
+     * @param resolverSettings
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeResolverSettings( ResolverSettings resolverSettings, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( resolverSettings != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( resolverSettings.isDebug() != null )
+            {
+                serializer.writeStartElement( "debug" );
+                serializer.writeCharacters( String.valueOf( resolverSettings.isDebug() ) );
+                serializer.writeEndElement();
+            }
+            if ( ( resolverSettings.getLocalRepositories() != null ) && ( resolverSettings.getLocalRepositories().size() > 0 ) )
+            {
+                serializer.writeStartElement( "localRepositories" );
+                for ( Iterator iter = resolverSettings.getLocalRepositories().iterator(); iter.hasNext(); )
+                {
+                    String localRepository = (String) iter.next();
+                    serializer.writeStartElement( "repository" );
+                    serializer.writeCharacters( localRepository );
+                    serializer.writeEndElement();
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( resolverSettings.getMetadataRepositories() != null ) && ( resolverSettings.getMetadataRepositories().size() > 0 ) )
+            {
+                serializer.writeStartElement( "metadataRepositories" );
+                for ( Iterator iter = resolverSettings.getMetadataRepositories().iterator(); iter.hasNext(); )
+                {
+                    String metadataRepository = (String) iter.next();
+                    serializer.writeStartElement( "repository" );
+                    serializer.writeCharacters( metadataRepository );
+                    serializer.writeEndElement();
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( resolverSettings.getPrefixes() != null ) && ( resolverSettings.getPrefixes().size() > 0 ) )
+            {
+                serializer.writeStartElement( "prefixes" );
+                for ( Iterator iter = resolverSettings.getPrefixes().iterator(); iter.hasNext(); )
+                {
+                    String prefix = (String) iter.next();
+                    serializer.writeStartElement( "prefix" );
+                    serializer.writeCharacters( prefix );
+                    serializer.writeEndElement();
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( resolverSettings.getBlacklist() != null ) && ( resolverSettings.getBlacklist().size() > 0 ) )
+            {
+                serializer.writeStartElement( "blacklist" );
+                for ( Iterator iter = resolverSettings.getBlacklist().iterator(); iter.hasNext(); )
+                {
+                    Artifact o = (Artifact) iter.next();
+                    writeArtifact( o, "artifact", serializer );
+                }
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeResolverSettings( ResolverSettings, String, XMLStreamWriter )
+
+    /**
+     * Method writeStereotype.
+     * 
+     * @param stereotype
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeStereotype( Stereotype stereotype, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( stereotype != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( stereotype.getType() != null )
+            {
+                serializer.writeStartElement( "type" );
+                serializer.writeCharacters( stereotype.getType() );
+                serializer.writeEndElement();
+            }
+            if ( stereotype.getExtension() != null )
+            {
+                serializer.writeStartElement( "extension" );
+                serializer.writeCharacters( stereotype.getExtension() );
+                serializer.writeEndElement();
+            }
+            if ( stereotype.getClassifier() != null )
+            {
+                serializer.writeStartElement( "classifier" );
+                serializer.writeCharacters( stereotype.getClassifier() );
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeStereotype( Stereotype, String, XMLStreamWriter )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/IndentingXMLStreamWriter.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/IndentingXMLStreamWriter.java
new file mode 100644
index 0000000..5fd340e
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/config/io/stax/IndentingXMLStreamWriter.java
@@ -0,0 +1,653 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.config.io.stax;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+
+/**
+ * Class IndentingXMLStreamWriter.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+class IndentingXMLStreamWriter
+    implements XMLStreamWriter
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field out.
+     */
+    private XMLStreamWriter out;
+
+    /**
+     * Field NEW_LINE.
+     */
+    private static final String NEW_LINE = "\n";
+
+    /**
+     * Field newLine.
+     */
+    private String newLine = NEW_LINE;
+
+    /**
+     * Field indent.
+     */
+    private String indent = "  ";
+
+    /**
+     * Field linePrefix.
+     */
+    private char[] linePrefix = "                        ".toCharArray();
+
+    /**
+     * Field depth.
+     */
+    private int depth;
+
+    /**
+     * Field states.
+     */
+    private byte[] states = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+    /**
+     * Field ELEMENT_HAS_DATA.
+     */
+    private static final int ELEMENT_HAS_DATA = 0x1;
+
+    /**
+     * Field ELEMENT_HAS_MARKUP.
+     */
+    private static final int ELEMENT_HAS_MARKUP = 0x2;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public IndentingXMLStreamWriter(XMLStreamWriter out)
+    {
+        this.out = out;
+    } //-- org.fedoraproject.xmvn.config.io.stax.IndentingXMLStreamWriter(XMLStreamWriter)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method close.
+     * 
+     * @throws XMLStreamException
+     */
+    public void close()
+        throws XMLStreamException
+    {
+        out.close();
+    } //-- void close()
+
+    /**
+     * Method flush.
+     * 
+     * @throws XMLStreamException
+     */
+    public void flush()
+        throws XMLStreamException
+    {
+        out.flush();
+    } //-- void flush()
+
+    /**
+     * Method getNamespaceContext.
+     * 
+     * @return NamespaceContext
+     */
+    public NamespaceContext getNamespaceContext()
+    {
+        return out.getNamespaceContext();
+    } //-- NamespaceContext getNamespaceContext()
+
+    /**
+     * Method getPrefix.
+     * 
+     * @param uri
+     * @throws XMLStreamException
+     * @return String
+     */
+    public String getPrefix( String uri )
+        throws XMLStreamException
+    {
+        return out.getPrefix( uri );
+    } //-- String getPrefix( String )
+
+    /**
+     * Method getProperty.
+     * 
+     * @param name
+     * @throws IllegalArgumentException
+     * @return Object
+     */
+    public Object getProperty( String name )
+        throws IllegalArgumentException
+    {
+        return out.getProperty( name );
+    } //-- Object getProperty( String )
+
+    /**
+     * Method setDefaultNamespace.
+     * 
+     * @param uri
+     * @throws XMLStreamException
+     */
+    public void setDefaultNamespace( String uri )
+        throws XMLStreamException
+    {
+        out.setDefaultNamespace( uri );
+    } //-- void setDefaultNamespace( String )
+
+    /**
+     * Method setNamespaceContext.
+     * 
+     * @param context
+     * @throws XMLStreamException
+     */
+    public void setNamespaceContext( NamespaceContext context )
+        throws XMLStreamException
+    {
+        out.setNamespaceContext( context );
+    } //-- void setNamespaceContext( NamespaceContext )
+
+    /**
+     * Method setPrefix.
+     * 
+     * @param prefix
+     * @param uri
+     * @throws XMLStreamException
+     */
+    public void setPrefix( String prefix, String uri )
+        throws XMLStreamException
+    {
+        out.setPrefix( prefix, uri );
+    } //-- void setPrefix( String, String )
+
+    /**
+     * Method writeAttribute.
+     * 
+     * @param localName
+     * @param value
+     * @throws XMLStreamException
+     */
+    public void writeAttribute( String localName, String value )
+        throws XMLStreamException
+    {
+        out.writeAttribute( localName, value );
+    } //-- void writeAttribute( String, String )
+
+    /**
+     * Method writeAttribute.
+     * 
+     * @param namespaceURI
+     * @param value
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeAttribute( String namespaceURI, String localName, String value )
+        throws XMLStreamException
+    {
+        out.writeAttribute( namespaceURI, localName, value );
+    } //-- void writeAttribute( String, String, String )
+
+    /**
+     * Method writeAttribute.
+     * 
+     * @param prefix
+     * @param value
+     * @param localName
+     * @param namespaceURI
+     * @throws XMLStreamException
+     */
+    public void writeAttribute( String prefix, String namespaceURI, String localName, String value )
+        throws XMLStreamException
+    {
+        out.writeAttribute( prefix, namespaceURI, localName, value );
+    } //-- void writeAttribute( String, String, String, String )
+
+    /**
+     * Method writeCData.
+     * 
+     * @param data
+     * @throws XMLStreamException
+     */
+    public void writeCData( String data )
+        throws XMLStreamException
+    {
+        out.writeCData( data );
+        afterData();
+    } //-- void writeCData( String )
+
+    /**
+     * Method writeCharacters.
+     * 
+     * @param text
+     * @throws XMLStreamException
+     */
+    public void writeCharacters( String text )
+        throws XMLStreamException
+    {
+        out.writeCharacters( text );
+        afterData();
+    } //-- void writeCharacters( String )
+
+    /**
+     * Method writeCharacters.
+     * 
+     * @param text
+     * @param len
+     * @param start
+     * @throws XMLStreamException
+     */
+    public void writeCharacters( char[] text, int start, int len )
+        throws XMLStreamException
+    {
+        out.writeCharacters( text, start, len );
+        afterData();
+    } //-- void writeCharacters( char[], int, int )
+
+    /**
+     * Method writeComment.
+     * 
+     * @param data
+     * @throws XMLStreamException
+     */
+    public void writeComment( String data )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeComment( data );
+        afterMarkup();
+    } //-- void writeComment( String )
+
+    /**
+     * Method writeDTD.
+     * 
+     * @param dtd
+     * @throws XMLStreamException
+     */
+    public void writeDTD( String dtd )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeDTD( dtd );
+        afterMarkup();
+    } //-- void writeDTD( String )
+
+    /**
+     * Method writeDefaultNamespace.
+     * 
+     * @param namespaceURI
+     * @throws XMLStreamException
+     */
+    public void writeDefaultNamespace( String namespaceURI )
+        throws XMLStreamException
+    {
+        out.writeDefaultNamespace( namespaceURI );
+    } //-- void writeDefaultNamespace( String )
+
+    /**
+     * Method writeEmptyElement.
+     * 
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeEmptyElement( String localName )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeEmptyElement( localName );
+        afterMarkup();
+    } //-- void writeEmptyElement( String )
+
+    /**
+     * Method writeEmptyElement.
+     * 
+     * @param namespaceURI
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeEmptyElement( String namespaceURI, String localName )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeEmptyElement( namespaceURI, localName );
+        afterMarkup();
+    } //-- void writeEmptyElement( String, String )
+
+    /**
+     * Method writeEmptyElement.
+     * 
+     * @param prefix
+     * @param localName
+     * @param namespaceURI
+     * @throws XMLStreamException
+     */
+    public void writeEmptyElement( String prefix, String namespaceURI, String localName )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeEmptyElement( prefix, namespaceURI, localName );
+        afterMarkup();
+    } //-- void writeEmptyElement( String, String, String )
+
+    /**
+     * Method writeEndDocument.
+     * 
+     * @throws XMLStreamException
+     */
+    public void writeEndDocument()
+        throws XMLStreamException
+    {
+        out.writeEndDocument(  );
+    } //-- void writeEndDocument()
+
+    /**
+     * Method writeEndElement.
+     * 
+     * @throws XMLStreamException
+     */
+    public void writeEndElement()
+        throws XMLStreamException
+    {
+        beforeEndElement();
+        out.writeEndElement(  );
+        afterEndElement();
+    } //-- void writeEndElement()
+
+    /**
+     * Method writeEntityRef.
+     * 
+     * @param name
+     * @throws XMLStreamException
+     */
+    public void writeEntityRef( String name )
+        throws XMLStreamException
+    {
+        out.writeEntityRef( name );
+        afterData();
+    } //-- void writeEntityRef( String )
+
+    /**
+     * Method writeNamespace.
+     * 
+     * @param prefix
+     * @param namespaceURI
+     * @throws XMLStreamException
+     */
+    public void writeNamespace( String prefix, String namespaceURI )
+        throws XMLStreamException
+    {
+        out.writeNamespace( prefix, namespaceURI );
+    } //-- void writeNamespace( String, String )
+
+    /**
+     * Method writeProcessingInstruction.
+     * 
+     * @param target
+     * @throws XMLStreamException
+     */
+    public void writeProcessingInstruction( String target )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeProcessingInstruction( target );
+        afterMarkup();
+    } //-- void writeProcessingInstruction( String )
+
+    /**
+     * Method writeProcessingInstruction.
+     * 
+     * @param target
+     * @param data
+     * @throws XMLStreamException
+     */
+    public void writeProcessingInstruction( String target, String data )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeProcessingInstruction( target, data );
+        afterMarkup();
+    } //-- void writeProcessingInstruction( String, String )
+
+    /**
+     * Method writeStartDocument.
+     * 
+     * @throws XMLStreamException
+     */
+    public void writeStartDocument()
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeStartDocument(  );
+        afterMarkup();
+    } //-- void writeStartDocument()
+
+    /**
+     * Method writeStartDocument.
+     * 
+     * @param version
+     * @throws XMLStreamException
+     */
+    public void writeStartDocument( String version )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeStartDocument( version );
+        afterMarkup();
+    } //-- void writeStartDocument( String )
+
+    /**
+     * Method writeStartDocument.
+     * 
+     * @param encoding
+     * @param version
+     * @throws XMLStreamException
+     */
+    public void writeStartDocument( String encoding, String version )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeStartDocument( encoding, version );
+        afterMarkup();
+    } //-- void writeStartDocument( String, String )
+
+    /**
+     * Method writeStartElement.
+     * 
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeStartElement( String localName )
+        throws XMLStreamException
+    {
+        beforeStartElement();
+        out.writeStartElement( localName );
+        afterStartElement();
+    } //-- void writeStartElement( String )
+
+    /**
+     * Method writeStartElement.
+     * 
+     * @param namespaceURI
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeStartElement( String namespaceURI, String localName )
+        throws XMLStreamException
+    {
+        beforeStartElement();
+        out.writeStartElement( namespaceURI, localName );
+        afterStartElement();
+    } //-- void writeStartElement( String, String )
+
+    /**
+     * Method writeStartElement.
+     * 
+     * @param prefix
+     * @param namespaceURI
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeStartElement( String prefix, String localName, String namespaceURI )
+        throws XMLStreamException
+    {
+        beforeStartElement();
+        out.writeStartElement( prefix, localName, namespaceURI );
+        afterStartElement();
+    } //-- void writeStartElement( String, String, String )
+
+    /**
+     * Method afterData.
+     */
+    private void afterData()
+    {
+        states[depth] |= ELEMENT_HAS_DATA;
+    } //-- void afterData()
+
+    /**
+     * Method afterEndElement.
+     */
+    private void afterEndElement()
+    {
+        if ( depth > 0 )
+        {
+            depth--;
+            if ( depth <= 0 )
+            {
+                newLine( 0 );
+            }
+        }
+    } //-- void afterEndElement()
+
+    /**
+     * Method afterMarkup.
+     */
+    private void afterMarkup()
+    {
+        states[depth] |= ELEMENT_HAS_MARKUP;
+    } //-- void afterMarkup()
+
+    /**
+     * Method afterStartElement.
+     */
+    private void afterStartElement()
+    {
+        afterMarkup();
+        depth++;
+    } //-- void afterStartElement()
+
+    /**
+     * Method beforeEndElement.
+     */
+    private void beforeEndElement()
+    {
+        if ( depth > 0 && states[depth] == ELEMENT_HAS_MARKUP )
+        {
+            newLine( depth - 1 );
+        }
+    } //-- void beforeEndElement()
+
+    /**
+     * Method beforeMarkup.
+     */
+    private void beforeMarkup()
+    {
+        int state = states[depth];
+        if ( ( state & ELEMENT_HAS_DATA ) == 0 && ( depth > 0 || state != 0 ) )
+        {
+            newLine( depth );
+            if ( depth > 0 && indent.length() > 0 )
+            {
+                afterMarkup();
+            }
+        }
+    } //-- void beforeMarkup()
+
+    /**
+     * Method beforeStartElement.
+     */
+    private void beforeStartElement()
+    {
+        beforeMarkup();
+        if ( states.length <= depth + 1 )
+        {
+            byte[] tmp = new byte[states.length * 2];
+            System.arraycopy( states, 0, tmp, 0, states.length );
+            states = tmp;
+        }
+        states[depth + 1] = 0;
+    } //-- void beforeStartElement()
+
+    /**
+     * Method getLineSeparator.
+     * 
+     * @return String
+     */
+    public String getLineSeparator()
+    {
+        try
+        {
+            return System.getProperty( "line.separator", NEW_LINE );
+        }
+        catch ( Exception e )
+        {
+            return NEW_LINE;
+        }
+    } //-- String getLineSeparator()
+
+    /**
+     * Method newLine.
+     * 
+     * @param depth
+     */
+    private void newLine( int depth )
+    {
+        try
+        {
+            out.writeCharacters( newLine );
+            int prefixLength = depth * indent.length();
+            while ( linePrefix.length < prefixLength )
+            {
+                char[] tmp = new char[linePrefix.length * 2];
+                System.arraycopy( linePrefix, 0, tmp, 0, linePrefix.length );
+                System.arraycopy( linePrefix, 0, tmp, linePrefix.length, linePrefix.length );
+                linePrefix = tmp;
+            }
+            out.writeCharacters( linePrefix, 0, prefixLength );
+        }
+        catch ( Exception e )
+        {
+        }
+    } //-- void newLine( int )
+
+    /**
+     * Method setNewLine.
+     * 
+     * @param newLine
+     */
+    public void setNewLine( String newLine )
+    {
+        this.newLine = newLine;
+    } //-- void setNewLine( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/ArtifactAlias.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/ArtifactAlias.java
new file mode 100644
index 0000000..4da0d4b
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/ArtifactAlias.java
@@ -0,0 +1,157 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.metadata;
+
+/**
+ * 
+ *         Alternative artifact identification coordinates.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ArtifactAlias
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Group ID of the artifact alias.
+     *           
+     */
+    private String groupId;
+
+    /**
+     * 
+     *             Artifact ID of the artifact alias.
+     *           
+     */
+    private String artifactId;
+
+    /**
+     * 
+     *             Extension of the artifact alias.
+     *           
+     */
+    private String extension = "jar";
+
+    /**
+     * 
+     *             Classifier of the artifact alias.
+     *           
+     */
+    private String classifier = "";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return ArtifactAlias
+     */
+    public ArtifactAlias clone()
+    {
+        try
+        {
+            ArtifactAlias copy = (ArtifactAlias) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ArtifactAlias clone()
+
+    /**
+     * Get artifact ID of the artifact alias.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get classifier of the artifact alias.
+     * 
+     * @return String
+     */
+    public String getClassifier()
+    {
+        return this.classifier;
+    } //-- String getClassifier()
+
+    /**
+     * Get extension of the artifact alias.
+     * 
+     * @return String
+     */
+    public String getExtension()
+    {
+        return this.extension;
+    } //-- String getExtension()
+
+    /**
+     * Get group ID of the artifact alias.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Set artifact ID of the artifact alias.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set classifier of the artifact alias.
+     * 
+     * @param classifier
+     */
+    public void setClassifier( String classifier )
+    {
+        this.classifier = classifier;
+    } //-- void setClassifier( String )
+
+    /**
+     * Set extension of the artifact alias.
+     * 
+     * @param extension
+     */
+    public void setExtension( String extension )
+    {
+        this.extension = extension;
+    } //-- void setExtension( String )
+
+    /**
+     * Set group ID of the artifact alias.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/ArtifactMetadata.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/ArtifactMetadata.java
new file mode 100644
index 0000000..b227b38
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/ArtifactMetadata.java
@@ -0,0 +1,520 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.metadata;
+
+/**
+ * 
+ *         Information about a single artifact.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class ArtifactMetadata
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Group identifier of the artifact.
+     *           
+     */
+    private String groupId;
+
+    /**
+     * 
+     *             Identifier of the artifact.
+     *           
+     */
+    private String artifactId;
+
+    /**
+     * 
+     *             Extension of artifact file.
+     *           
+     */
+    private String extension = "jar";
+
+    /**
+     * 
+     *             Classifier of the artifact.
+     *           
+     */
+    private String classifier = "";
+
+    /**
+     * 
+     *             Artifact version.  This is always upstream
+     * version, never
+     *             compat version nor SYSTEM.
+     *           
+     */
+    private String version;
+
+    /**
+     * 
+     *             Absolute path to artifact file stored in the
+     * local file
+     *             system.
+     *           
+     */
+    private String path;
+
+    /**
+     * 
+     *             A namespace within which this artifact is
+     * stored.  This
+     *             usually is an identifier of software collection.
+     *           
+     */
+    private String namespace = "";
+
+    /**
+     * 
+     *             Universally unique identifier of this artifact.
+     *           
+     */
+    private String uuid;
+
+    /**
+     * Field properties.
+     */
+    private java.util.Properties properties;
+
+    /**
+     * Field compatVersions.
+     */
+    private java.util.List<String> compatVersions;
+
+    /**
+     * Field aliases.
+     */
+    private java.util.List<ArtifactAlias> aliases;
+
+    /**
+     * Field dependencies.
+     */
+    private java.util.List<Dependency> dependencies;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addCompatVersion.
+     * 
+     * @param string
+     */
+    public void addCompatVersion( String string )
+    {
+        getCompatVersions().add( string );
+    } //-- void addCompatVersion( String )
+
+    /**
+     * Method addDependency.
+     * 
+     * @param dependency
+     */
+    public void addDependency( Dependency dependency )
+    {
+        getDependencies().add( dependency );
+    } //-- void addDependency( Dependency )
+
+    /**
+     * Method addProperty.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addProperty( String key, String value )
+    {
+        getProperties().put( key, value );
+    } //-- void addProperty( String, String )
+
+    /**
+     * Method clone.
+     * 
+     * @return ArtifactMetadata
+     */
+    public ArtifactMetadata clone()
+    {
+        try
+        {
+            ArtifactMetadata copy = (ArtifactMetadata) super.clone();
+
+            if ( this.properties != null )
+            {
+                copy.properties = (java.util.Properties) this.properties.clone();
+            }
+
+            if ( this.compatVersions != null )
+            {
+                copy.compatVersions = new java.util.ArrayList<String>();
+                copy.compatVersions.addAll( this.compatVersions );
+            }
+
+            if ( this.aliases != null )
+            {
+                copy.aliases = new java.util.ArrayList<ArtifactAlias>();
+                for ( ArtifactAlias item : this.aliases )
+                {
+                    copy.aliases.add( ( (ArtifactAlias) item).clone() );
+                }
+            }
+
+            if ( this.dependencies != null )
+            {
+                copy.dependencies = new java.util.ArrayList<Dependency>();
+                for ( Dependency item : this.dependencies )
+                {
+                    copy.dependencies.add( ( (Dependency) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- ArtifactMetadata clone()
+
+    /**
+     * Method getAliases.
+     * 
+     * @return List
+     */
+    public java.util.List<ArtifactAlias> getAliases()
+    {
+        if ( this.aliases == null )
+        {
+            this.aliases = new java.util.ArrayList<ArtifactAlias>();
+        }
+
+        return this.aliases;
+    } //-- java.util.List<ArtifactAlias> getAliases()
+
+    /**
+     * Get identifier of the artifact.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get classifier of the artifact.
+     * 
+     * @return String
+     */
+    public String getClassifier()
+    {
+        return this.classifier;
+    } //-- String getClassifier()
+
+    /**
+     * Method getCompatVersions.
+     * 
+     * @return List
+     */
+    public java.util.List<String> getCompatVersions()
+    {
+        if ( this.compatVersions == null )
+        {
+            this.compatVersions = new java.util.ArrayList<String>();
+        }
+
+        return this.compatVersions;
+    } //-- java.util.List<String> getCompatVersions()
+
+    /**
+     * Method getDependencies.
+     * 
+     * @return List
+     */
+    public java.util.List<Dependency> getDependencies()
+    {
+        if ( this.dependencies == null )
+        {
+            this.dependencies = new java.util.ArrayList<Dependency>();
+        }
+
+        return this.dependencies;
+    } //-- java.util.List<Dependency> getDependencies()
+
+    /**
+     * Get extension of artifact file.
+     * 
+     * @return String
+     */
+    public String getExtension()
+    {
+        return this.extension;
+    } //-- String getExtension()
+
+    /**
+     * Get group identifier of the artifact.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Get a namespace within which this artifact is stored.  This
+     *             usually is an identifier of software collection.
+     * 
+     * @return String
+     */
+    public String getNamespace()
+    {
+        return this.namespace;
+    } //-- String getNamespace()
+
+    /**
+     * Get absolute path to artifact file stored in the local file
+     *             system.
+     * 
+     * @return String
+     */
+    public String getPath()
+    {
+        return this.path;
+    } //-- String getPath()
+
+    /**
+     * Method getProperties.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getProperties()
+    {
+        if ( this.properties == null )
+        {
+            this.properties = new java.util.Properties();
+        }
+
+        return this.properties;
+    } //-- java.util.Properties getProperties()
+
+    /**
+     * Get universally unique identifier of this artifact.
+     * 
+     * @return String
+     */
+    public String getUuid()
+    {
+        return this.uuid;
+    } //-- String getUuid()
+
+    /**
+     * Get artifact version.  This is always upstream version,
+     * never
+     *             compat version nor SYSTEM.
+     * 
+     * @return String
+     */
+    public String getVersion()
+    {
+        return this.version;
+    } //-- String getVersion()
+
+    /**
+     * Method removeCompatVersion.
+     * 
+     * @param string
+     */
+    public void removeCompatVersion( String string )
+    {
+        getCompatVersions().remove( string );
+    } //-- void removeCompatVersion( String )
+
+    /**
+     * Method removeDependency.
+     * 
+     * @param dependency
+     */
+    public void removeDependency( Dependency dependency )
+    {
+        getDependencies().remove( dependency );
+    } //-- void removeDependency( Dependency )
+
+    /**
+     * Set alternative identifiers of the artifact.
+     * 
+     * @param aliases
+     */
+    public void setAliases( java.util.List<ArtifactAlias> aliases )
+    {
+        this.aliases = aliases;
+    } //-- void setAliases( java.util.List )
+
+    /**
+     * Set identifier of the artifact.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set classifier of the artifact.
+     * 
+     * @param classifier
+     */
+    public void setClassifier( String classifier )
+    {
+        this.classifier = classifier;
+    } //-- void setClassifier( String )
+
+    /**
+     * Set compatibility versions of this artifact.  If the list is
+     *             empty then this artifact is not considered as
+     *             compatibility artifact.
+     * 
+     * @param compatVersions
+     */
+    public void setCompatVersions( java.util.List<String> compatVersions )
+    {
+        this.compatVersions = compatVersions;
+    } //-- void setCompatVersions( java.util.List )
+
+    /**
+     * Set list of artifact dependencies.
+     * 
+     * @param dependencies
+     */
+    public void setDependencies( java.util.List<Dependency> dependencies )
+    {
+        this.dependencies = dependencies;
+    } //-- void setDependencies( java.util.List )
+
+    /**
+     * Set extension of artifact file.
+     * 
+     * @param extension
+     */
+    public void setExtension( String extension )
+    {
+        this.extension = extension;
+    } //-- void setExtension( String )
+
+    /**
+     * Set group identifier of the artifact.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * Set a namespace within which this artifact is stored.  This
+     *             usually is an identifier of software collection.
+     * 
+     * @param namespace
+     */
+    public void setNamespace( String namespace )
+    {
+        this.namespace = namespace;
+    } //-- void setNamespace( String )
+
+    /**
+     * Set absolute path to artifact file stored in the local file
+     *             system.
+     * 
+     * @param path
+     */
+    public void setPath( String path )
+    {
+        this.path = path;
+    } //-- void setPath( String )
+
+    /**
+     * Set extra properties of this artifact.
+     * 
+     * @param properties
+     */
+    public void setProperties( java.util.Properties properties )
+    {
+        this.properties = properties;
+    } //-- void setProperties( java.util.Properties )
+
+    /**
+     * Set universally unique identifier of this artifact.
+     * 
+     * @param uuid
+     */
+    public void setUuid( String uuid )
+    {
+        this.uuid = uuid;
+    } //-- void setUuid( String )
+
+    /**
+     * Set artifact version.  This is always upstream version,
+     * never
+     *             compat version nor SYSTEM.
+     * 
+     * @param version
+     */
+    public void setVersion( String version )
+    {
+        this.version = version;
+    } //-- void setVersion( String )
+
+    
+            
+    /**
+     * Add an alias.
+     * @param alias alias to be added
+     */
+    public void addAlias( ArtifactAlias alias )
+    {
+        getAliases().add( alias );
+    }
+
+    /**
+     * Remove an alias.
+     * @param alias alias to be removed
+     */
+    public void removeAlias( ArtifactAlias alias )
+    {
+        getAliases().remove( alias );
+    }
+
+    /**
+     * Return list of versions from which this artifact can be resolved.
+     * <p>
+     * For non-compat artifacts this method returns a singleton list containing default artfact version.
+     * Otherwise it returns a list of compat versions.
+     * 
+     * @return non-empty list of versions, never {@code null}
+     */
+    public java.util.List<String> getResolvableVersions()
+    {
+        java.util.List<String> versions = java.util.Collections.unmodifiableList( getCompatVersions() );
+
+        if ( versions.isEmpty() )
+            versions = java.util.Collections.singletonList( org.fedoraproject.xmvn.artifact.Artifact.DEFAULT_VERSION );
+
+        return versions;
+    }
+            
+          
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/Dependency.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/Dependency.java
new file mode 100644
index 0000000..ad83f24
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/Dependency.java
@@ -0,0 +1,323 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.metadata;
+
+/**
+ * 
+ *         Description of dependency artifact.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class Dependency
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Group ID of the dependency artifact.
+     *           
+     */
+    private String groupId;
+
+    /**
+     * 
+     *             Artifact ID of the dependency artifact.
+     *           
+     */
+    private String artifactId;
+
+    /**
+     * 
+     *             Extension of the dependency artifact.
+     *           
+     */
+    private String extension = "jar";
+
+    /**
+     * 
+     *             Classifier of the dependency artifact.
+     *           
+     */
+    private String classifier = "";
+
+    /**
+     * 
+     *             Version of the dependency artifact as defined in
+     * the main
+     *             artifact descriptor.  This may be a version
+     * range as
+     *             supported by Aether.
+     *           
+     */
+    private String requestedVersion = "SYSTEM";
+
+    /**
+     * 
+     *             Version of the dependency artifact, as resolved
+     * during
+     *             build.  Absence of this field indicates a
+     * dependency on
+     *             default artifact version.
+     *           
+     */
+    private String resolvedVersion = "SYSTEM";
+
+    /**
+     * 
+     *             A namespace within which this artifact is
+     * stored.  This
+     *             usually is an identifier of software collection.
+     *           
+     */
+    private String namespace = "";
+
+    /**
+     * Field exclusions.
+     */
+    private java.util.List<DependencyExclusion> exclusions;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addExclusion.
+     * 
+     * @param dependencyExclusion
+     */
+    public void addExclusion( DependencyExclusion dependencyExclusion )
+    {
+        getExclusions().add( dependencyExclusion );
+    } //-- void addExclusion( DependencyExclusion )
+
+    /**
+     * Method clone.
+     * 
+     * @return Dependency
+     */
+    public Dependency clone()
+    {
+        try
+        {
+            Dependency copy = (Dependency) super.clone();
+
+            if ( this.exclusions != null )
+            {
+                copy.exclusions = new java.util.ArrayList<DependencyExclusion>();
+                for ( DependencyExclusion item : this.exclusions )
+                {
+                    copy.exclusions.add( ( (DependencyExclusion) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- Dependency clone()
+
+    /**
+     * Get artifact ID of the dependency artifact.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get classifier of the dependency artifact.
+     * 
+     * @return String
+     */
+    public String getClassifier()
+    {
+        return this.classifier;
+    } //-- String getClassifier()
+
+    /**
+     * Method getExclusions.
+     * 
+     * @return List
+     */
+    public java.util.List<DependencyExclusion> getExclusions()
+    {
+        if ( this.exclusions == null )
+        {
+            this.exclusions = new java.util.ArrayList<DependencyExclusion>();
+        }
+
+        return this.exclusions;
+    } //-- java.util.List<DependencyExclusion> getExclusions()
+
+    /**
+     * Get extension of the dependency artifact.
+     * 
+     * @return String
+     */
+    public String getExtension()
+    {
+        return this.extension;
+    } //-- String getExtension()
+
+    /**
+     * Get group ID of the dependency artifact.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Get a namespace within which this artifact is stored.  This
+     *             usually is an identifier of software collection.
+     * 
+     * @return String
+     */
+    public String getNamespace()
+    {
+        return this.namespace;
+    } //-- String getNamespace()
+
+    /**
+     * Get version of the dependency artifact as defined in the
+     * main
+     *             artifact descriptor.  This may be a version
+     * range as
+     *             supported by Aether.
+     * 
+     * @return String
+     */
+    public String getRequestedVersion()
+    {
+        return this.requestedVersion;
+    } //-- String getRequestedVersion()
+
+    /**
+     * Get version of the dependency artifact, as resolved during
+     *             build.  Absence of this field indicates a
+     * dependency on
+     *             default artifact version.
+     * 
+     * @return String
+     */
+    public String getResolvedVersion()
+    {
+        return this.resolvedVersion;
+    } //-- String getResolvedVersion()
+
+    /**
+     * Method removeExclusion.
+     * 
+     * @param dependencyExclusion
+     */
+    public void removeExclusion( DependencyExclusion dependencyExclusion )
+    {
+        getExclusions().remove( dependencyExclusion );
+    } //-- void removeExclusion( DependencyExclusion )
+
+    /**
+     * Set artifact ID of the dependency artifact.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set classifier of the dependency artifact.
+     * 
+     * @param classifier
+     */
+    public void setClassifier( String classifier )
+    {
+        this.classifier = classifier;
+    } //-- void setClassifier( String )
+
+    /**
+     * Set list of dependency exclusions.
+     * 
+     * @param exclusions
+     */
+    public void setExclusions( java.util.List<DependencyExclusion> exclusions )
+    {
+        this.exclusions = exclusions;
+    } //-- void setExclusions( java.util.List )
+
+    /**
+     * Set extension of the dependency artifact.
+     * 
+     * @param extension
+     */
+    public void setExtension( String extension )
+    {
+        this.extension = extension;
+    } //-- void setExtension( String )
+
+    /**
+     * Set group ID of the dependency artifact.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+    /**
+     * Set a namespace within which this artifact is stored.  This
+     *             usually is an identifier of software collection.
+     * 
+     * @param namespace
+     */
+    public void setNamespace( String namespace )
+    {
+        this.namespace = namespace;
+    } //-- void setNamespace( String )
+
+    /**
+     * Set version of the dependency artifact as defined in the
+     * main
+     *             artifact descriptor.  This may be a version
+     * range as
+     *             supported by Aether.
+     * 
+     * @param requestedVersion
+     */
+    public void setRequestedVersion( String requestedVersion )
+    {
+        this.requestedVersion = requestedVersion;
+    } //-- void setRequestedVersion( String )
+
+    /**
+     * Set version of the dependency artifact, as resolved during
+     *             build.  Absence of this field indicates a
+     * dependency on
+     *             default artifact version.
+     * 
+     * @param resolvedVersion
+     */
+    public void setResolvedVersion( String resolvedVersion )
+    {
+        this.resolvedVersion = resolvedVersion;
+    } //-- void setResolvedVersion( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/DependencyExclusion.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/DependencyExclusion.java
new file mode 100644
index 0000000..419c939
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/DependencyExclusion.java
@@ -0,0 +1,103 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.metadata;
+
+/**
+ * 
+ *         Description of artifact excluded from dependency tree.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class DependencyExclusion
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Group ID of the excluded artifact.
+     *           
+     */
+    private String groupId;
+
+    /**
+     * 
+     *             Artifact ID of the excluded artifact.
+     *           
+     */
+    private String artifactId;
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return DependencyExclusion
+     */
+    public DependencyExclusion clone()
+    {
+        try
+        {
+            DependencyExclusion copy = (DependencyExclusion) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- DependencyExclusion clone()
+
+    /**
+     * Get artifact ID of the excluded artifact.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get group ID of the excluded artifact.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Set artifact ID of the excluded artifact.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set group ID of the excluded artifact.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/PackageMetadata.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/PackageMetadata.java
new file mode 100644
index 0000000..762652f
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/PackageMetadata.java
@@ -0,0 +1,270 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.metadata;
+
+/**
+ * 
+ *         Root element of the metadata file.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class PackageMetadata
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Universally unique identifier of this piece of
+     * metadata.
+     *           
+     */
+    private String uuid;
+
+    /**
+     * Field properties.
+     */
+    private java.util.Properties properties;
+
+    /**
+     * Field artifacts.
+     */
+    private java.util.List<ArtifactMetadata> artifacts;
+
+    /**
+     * Field skippedArtifacts.
+     */
+    private java.util.List<SkippedArtifactMetadata> skippedArtifacts;
+
+    /**
+     * Field modelEncoding.
+     */
+    private String modelEncoding = "UTF-8";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method addArtifact.
+     * 
+     * @param artifactMetadata
+     */
+    public void addArtifact( ArtifactMetadata artifactMetadata )
+    {
+        getArtifacts().add( artifactMetadata );
+    } //-- void addArtifact( ArtifactMetadata )
+
+    /**
+     * Method addProperty.
+     * 
+     * @param key
+     * @param value
+     */
+    public void addProperty( String key, String value )
+    {
+        getProperties().put( key, value );
+    } //-- void addProperty( String, String )
+
+    /**
+     * Method addSkippedArtifact.
+     * 
+     * @param skippedArtifactMetadata
+     */
+    public void addSkippedArtifact( SkippedArtifactMetadata skippedArtifactMetadata )
+    {
+        getSkippedArtifacts().add( skippedArtifactMetadata );
+    } //-- void addSkippedArtifact( SkippedArtifactMetadata )
+
+    /**
+     * Method clone.
+     * 
+     * @return PackageMetadata
+     */
+    public PackageMetadata clone()
+    {
+        try
+        {
+            PackageMetadata copy = (PackageMetadata) super.clone();
+
+            if ( this.properties != null )
+            {
+                copy.properties = (java.util.Properties) this.properties.clone();
+            }
+
+            if ( this.artifacts != null )
+            {
+                copy.artifacts = new java.util.ArrayList<ArtifactMetadata>();
+                for ( ArtifactMetadata item : this.artifacts )
+                {
+                    copy.artifacts.add( ( (ArtifactMetadata) item).clone() );
+                }
+            }
+
+            if ( this.skippedArtifacts != null )
+            {
+                copy.skippedArtifacts = new java.util.ArrayList<SkippedArtifactMetadata>();
+                for ( SkippedArtifactMetadata item : this.skippedArtifacts )
+                {
+                    copy.skippedArtifacts.add( ( (SkippedArtifactMetadata) item).clone() );
+                }
+            }
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- PackageMetadata clone()
+
+    /**
+     * Method getArtifacts.
+     * 
+     * @return List
+     */
+    public java.util.List<ArtifactMetadata> getArtifacts()
+    {
+        if ( this.artifacts == null )
+        {
+            this.artifacts = new java.util.ArrayList<ArtifactMetadata>();
+        }
+
+        return this.artifacts;
+    } //-- java.util.List<ArtifactMetadata> getArtifacts()
+
+    /**
+     * Get the modelEncoding field.
+     * 
+     * @return String
+     */
+    public String getModelEncoding()
+    {
+        return this.modelEncoding;
+    } //-- String getModelEncoding()
+
+    /**
+     * Method getProperties.
+     * 
+     * @return Properties
+     */
+    public java.util.Properties getProperties()
+    {
+        if ( this.properties == null )
+        {
+            this.properties = new java.util.Properties();
+        }
+
+        return this.properties;
+    } //-- java.util.Properties getProperties()
+
+    /**
+     * Method getSkippedArtifacts.
+     * 
+     * @return List
+     */
+    public java.util.List<SkippedArtifactMetadata> getSkippedArtifacts()
+    {
+        if ( this.skippedArtifacts == null )
+        {
+            this.skippedArtifacts = new java.util.ArrayList<SkippedArtifactMetadata>();
+        }
+
+        return this.skippedArtifacts;
+    } //-- java.util.List<SkippedArtifactMetadata> getSkippedArtifacts()
+
+    /**
+     * Get universally unique identifier of this piece of metadata.
+     * 
+     * @return String
+     */
+    public String getUuid()
+    {
+        return this.uuid;
+    } //-- String getUuid()
+
+    /**
+     * Method removeArtifact.
+     * 
+     * @param artifactMetadata
+     */
+    public void removeArtifact( ArtifactMetadata artifactMetadata )
+    {
+        getArtifacts().remove( artifactMetadata );
+    } //-- void removeArtifact( ArtifactMetadata )
+
+    /**
+     * Method removeSkippedArtifact.
+     * 
+     * @param skippedArtifactMetadata
+     */
+    public void removeSkippedArtifact( SkippedArtifactMetadata skippedArtifactMetadata )
+    {
+        getSkippedArtifacts().remove( skippedArtifactMetadata );
+    } //-- void removeSkippedArtifact( SkippedArtifactMetadata )
+
+    /**
+     * Set list of installed artifacts described by this piece of
+     *             metadata.
+     * 
+     * @param artifacts
+     */
+    public void setArtifacts( java.util.List<ArtifactMetadata> artifacts )
+    {
+        this.artifacts = artifacts;
+    } //-- void setArtifacts( java.util.List )
+
+    /**
+     * Set the modelEncoding field.
+     * 
+     * @param modelEncoding
+     */
+    public void setModelEncoding( String modelEncoding )
+    {
+        this.modelEncoding = modelEncoding;
+    } //-- void setModelEncoding( String )
+
+    /**
+     * Set properties of this piece of metadata.
+     * 
+     * @param properties
+     */
+    public void setProperties( java.util.Properties properties )
+    {
+        this.properties = properties;
+    } //-- void setProperties( java.util.Properties )
+
+    /**
+     * Set list of artifacts built but not installed in any
+     * package.
+     *             Useful for detecting broken package
+     * dependencies.
+     * 
+     * @param skippedArtifacts
+     */
+    public void setSkippedArtifacts( java.util.List<SkippedArtifactMetadata> skippedArtifacts )
+    {
+        this.skippedArtifacts = skippedArtifacts;
+    } //-- void setSkippedArtifacts( java.util.List )
+
+    /**
+     * Set universally unique identifier of this piece of metadata.
+     * 
+     * @param uuid
+     */
+    public void setUuid( String uuid )
+    {
+        this.uuid = uuid;
+    } //-- void setUuid( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/SkippedArtifactMetadata.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/SkippedArtifactMetadata.java
new file mode 100644
index 0000000..0ccc123
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/SkippedArtifactMetadata.java
@@ -0,0 +1,159 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.metadata;
+
+/**
+ * 
+ *         Information about artifact which was built, but not
+ * installed
+ *         into any package.
+ *       
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class SkippedArtifactMetadata
+    implements java.io.Serializable, java.lang.Cloneable
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * 
+     *             Group ID of skipped artifact.
+     *           
+     */
+    private String groupId;
+
+    /**
+     * 
+     *             Artifact ID of skipped artifact.
+     *           
+     */
+    private String artifactId;
+
+    /**
+     * 
+     *             Extension of skipped artifact.
+     *           
+     */
+    private String extension = "jar";
+
+    /**
+     * 
+     *             Classifier of skipped artifact.
+     *           
+     */
+    private String classifier = "";
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method clone.
+     * 
+     * @return SkippedArtifactMetadata
+     */
+    public SkippedArtifactMetadata clone()
+    {
+        try
+        {
+            SkippedArtifactMetadata copy = (SkippedArtifactMetadata) super.clone();
+
+            return copy;
+        }
+        catch ( java.lang.Exception ex )
+        {
+            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
+                + " does not support clone()" ).initCause( ex );
+        }
+    } //-- SkippedArtifactMetadata clone()
+
+    /**
+     * Get artifact ID of skipped artifact.
+     * 
+     * @return String
+     */
+    public String getArtifactId()
+    {
+        return this.artifactId;
+    } //-- String getArtifactId()
+
+    /**
+     * Get classifier of skipped artifact.
+     * 
+     * @return String
+     */
+    public String getClassifier()
+    {
+        return this.classifier;
+    } //-- String getClassifier()
+
+    /**
+     * Get extension of skipped artifact.
+     * 
+     * @return String
+     */
+    public String getExtension()
+    {
+        return this.extension;
+    } //-- String getExtension()
+
+    /**
+     * Get group ID of skipped artifact.
+     * 
+     * @return String
+     */
+    public String getGroupId()
+    {
+        return this.groupId;
+    } //-- String getGroupId()
+
+    /**
+     * Set artifact ID of skipped artifact.
+     * 
+     * @param artifactId
+     */
+    public void setArtifactId( String artifactId )
+    {
+        this.artifactId = artifactId;
+    } //-- void setArtifactId( String )
+
+    /**
+     * Set classifier of skipped artifact.
+     * 
+     * @param classifier
+     */
+    public void setClassifier( String classifier )
+    {
+        this.classifier = classifier;
+    } //-- void setClassifier( String )
+
+    /**
+     * Set extension of skipped artifact.
+     * 
+     * @param extension
+     */
+    public void setExtension( String extension )
+    {
+        this.extension = extension;
+    } //-- void setExtension( String )
+
+    /**
+     * Set group ID of skipped artifact.
+     * 
+     * @param groupId
+     */
+    public void setGroupId( String groupId )
+    {
+        this.groupId = groupId;
+    } //-- void setGroupId( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/IndentingXMLStreamWriter.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/IndentingXMLStreamWriter.java
new file mode 100644
index 0000000..510caf1
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/IndentingXMLStreamWriter.java
@@ -0,0 +1,653 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.metadata.io.stax;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamWriter;
+
+/**
+ * Class IndentingXMLStreamWriter.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+class IndentingXMLStreamWriter
+    implements XMLStreamWriter
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field out.
+     */
+    private XMLStreamWriter out;
+
+    /**
+     * Field NEW_LINE.
+     */
+    private static final String NEW_LINE = "\n";
+
+    /**
+     * Field newLine.
+     */
+    private String newLine = NEW_LINE;
+
+    /**
+     * Field indent.
+     */
+    private String indent = "  ";
+
+    /**
+     * Field linePrefix.
+     */
+    private char[] linePrefix = "                        ".toCharArray();
+
+    /**
+     * Field depth.
+     */
+    private int depth;
+
+    /**
+     * Field states.
+     */
+    private byte[] states = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+
+    /**
+     * Field ELEMENT_HAS_DATA.
+     */
+    private static final int ELEMENT_HAS_DATA = 0x1;
+
+    /**
+     * Field ELEMENT_HAS_MARKUP.
+     */
+    private static final int ELEMENT_HAS_MARKUP = 0x2;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public IndentingXMLStreamWriter(XMLStreamWriter out)
+    {
+        this.out = out;
+    } //-- org.fedoraproject.xmvn.metadata.io.stax.IndentingXMLStreamWriter(XMLStreamWriter)
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method close.
+     * 
+     * @throws XMLStreamException
+     */
+    public void close()
+        throws XMLStreamException
+    {
+        out.close();
+    } //-- void close()
+
+    /**
+     * Method flush.
+     * 
+     * @throws XMLStreamException
+     */
+    public void flush()
+        throws XMLStreamException
+    {
+        out.flush();
+    } //-- void flush()
+
+    /**
+     * Method getNamespaceContext.
+     * 
+     * @return NamespaceContext
+     */
+    public NamespaceContext getNamespaceContext()
+    {
+        return out.getNamespaceContext();
+    } //-- NamespaceContext getNamespaceContext()
+
+    /**
+     * Method getPrefix.
+     * 
+     * @param uri
+     * @throws XMLStreamException
+     * @return String
+     */
+    public String getPrefix( String uri )
+        throws XMLStreamException
+    {
+        return out.getPrefix( uri );
+    } //-- String getPrefix( String )
+
+    /**
+     * Method getProperty.
+     * 
+     * @param name
+     * @throws IllegalArgumentException
+     * @return Object
+     */
+    public Object getProperty( String name )
+        throws IllegalArgumentException
+    {
+        return out.getProperty( name );
+    } //-- Object getProperty( String )
+
+    /**
+     * Method setDefaultNamespace.
+     * 
+     * @param uri
+     * @throws XMLStreamException
+     */
+    public void setDefaultNamespace( String uri )
+        throws XMLStreamException
+    {
+        out.setDefaultNamespace( uri );
+    } //-- void setDefaultNamespace( String )
+
+    /**
+     * Method setNamespaceContext.
+     * 
+     * @param context
+     * @throws XMLStreamException
+     */
+    public void setNamespaceContext( NamespaceContext context )
+        throws XMLStreamException
+    {
+        out.setNamespaceContext( context );
+    } //-- void setNamespaceContext( NamespaceContext )
+
+    /**
+     * Method setPrefix.
+     * 
+     * @param prefix
+     * @param uri
+     * @throws XMLStreamException
+     */
+    public void setPrefix( String prefix, String uri )
+        throws XMLStreamException
+    {
+        out.setPrefix( prefix, uri );
+    } //-- void setPrefix( String, String )
+
+    /**
+     * Method writeAttribute.
+     * 
+     * @param localName
+     * @param value
+     * @throws XMLStreamException
+     */
+    public void writeAttribute( String localName, String value )
+        throws XMLStreamException
+    {
+        out.writeAttribute( localName, value );
+    } //-- void writeAttribute( String, String )
+
+    /**
+     * Method writeAttribute.
+     * 
+     * @param namespaceURI
+     * @param value
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeAttribute( String namespaceURI, String localName, String value )
+        throws XMLStreamException
+    {
+        out.writeAttribute( namespaceURI, localName, value );
+    } //-- void writeAttribute( String, String, String )
+
+    /**
+     * Method writeAttribute.
+     * 
+     * @param prefix
+     * @param value
+     * @param localName
+     * @param namespaceURI
+     * @throws XMLStreamException
+     */
+    public void writeAttribute( String prefix, String namespaceURI, String localName, String value )
+        throws XMLStreamException
+    {
+        out.writeAttribute( prefix, namespaceURI, localName, value );
+    } //-- void writeAttribute( String, String, String, String )
+
+    /**
+     * Method writeCData.
+     * 
+     * @param data
+     * @throws XMLStreamException
+     */
+    public void writeCData( String data )
+        throws XMLStreamException
+    {
+        out.writeCData( data );
+        afterData();
+    } //-- void writeCData( String )
+
+    /**
+     * Method writeCharacters.
+     * 
+     * @param text
+     * @throws XMLStreamException
+     */
+    public void writeCharacters( String text )
+        throws XMLStreamException
+    {
+        out.writeCharacters( text );
+        afterData();
+    } //-- void writeCharacters( String )
+
+    /**
+     * Method writeCharacters.
+     * 
+     * @param text
+     * @param len
+     * @param start
+     * @throws XMLStreamException
+     */
+    public void writeCharacters( char[] text, int start, int len )
+        throws XMLStreamException
+    {
+        out.writeCharacters( text, start, len );
+        afterData();
+    } //-- void writeCharacters( char[], int, int )
+
+    /**
+     * Method writeComment.
+     * 
+     * @param data
+     * @throws XMLStreamException
+     */
+    public void writeComment( String data )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeComment( data );
+        afterMarkup();
+    } //-- void writeComment( String )
+
+    /**
+     * Method writeDTD.
+     * 
+     * @param dtd
+     * @throws XMLStreamException
+     */
+    public void writeDTD( String dtd )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeDTD( dtd );
+        afterMarkup();
+    } //-- void writeDTD( String )
+
+    /**
+     * Method writeDefaultNamespace.
+     * 
+     * @param namespaceURI
+     * @throws XMLStreamException
+     */
+    public void writeDefaultNamespace( String namespaceURI )
+        throws XMLStreamException
+    {
+        out.writeDefaultNamespace( namespaceURI );
+    } //-- void writeDefaultNamespace( String )
+
+    /**
+     * Method writeEmptyElement.
+     * 
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeEmptyElement( String localName )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeEmptyElement( localName );
+        afterMarkup();
+    } //-- void writeEmptyElement( String )
+
+    /**
+     * Method writeEmptyElement.
+     * 
+     * @param namespaceURI
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeEmptyElement( String namespaceURI, String localName )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeEmptyElement( namespaceURI, localName );
+        afterMarkup();
+    } //-- void writeEmptyElement( String, String )
+
+    /**
+     * Method writeEmptyElement.
+     * 
+     * @param prefix
+     * @param localName
+     * @param namespaceURI
+     * @throws XMLStreamException
+     */
+    public void writeEmptyElement( String prefix, String namespaceURI, String localName )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeEmptyElement( prefix, namespaceURI, localName );
+        afterMarkup();
+    } //-- void writeEmptyElement( String, String, String )
+
+    /**
+     * Method writeEndDocument.
+     * 
+     * @throws XMLStreamException
+     */
+    public void writeEndDocument()
+        throws XMLStreamException
+    {
+        out.writeEndDocument(  );
+    } //-- void writeEndDocument()
+
+    /**
+     * Method writeEndElement.
+     * 
+     * @throws XMLStreamException
+     */
+    public void writeEndElement()
+        throws XMLStreamException
+    {
+        beforeEndElement();
+        out.writeEndElement(  );
+        afterEndElement();
+    } //-- void writeEndElement()
+
+    /**
+     * Method writeEntityRef.
+     * 
+     * @param name
+     * @throws XMLStreamException
+     */
+    public void writeEntityRef( String name )
+        throws XMLStreamException
+    {
+        out.writeEntityRef( name );
+        afterData();
+    } //-- void writeEntityRef( String )
+
+    /**
+     * Method writeNamespace.
+     * 
+     * @param prefix
+     * @param namespaceURI
+     * @throws XMLStreamException
+     */
+    public void writeNamespace( String prefix, String namespaceURI )
+        throws XMLStreamException
+    {
+        out.writeNamespace( prefix, namespaceURI );
+    } //-- void writeNamespace( String, String )
+
+    /**
+     * Method writeProcessingInstruction.
+     * 
+     * @param target
+     * @throws XMLStreamException
+     */
+    public void writeProcessingInstruction( String target )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeProcessingInstruction( target );
+        afterMarkup();
+    } //-- void writeProcessingInstruction( String )
+
+    /**
+     * Method writeProcessingInstruction.
+     * 
+     * @param target
+     * @param data
+     * @throws XMLStreamException
+     */
+    public void writeProcessingInstruction( String target, String data )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeProcessingInstruction( target, data );
+        afterMarkup();
+    } //-- void writeProcessingInstruction( String, String )
+
+    /**
+     * Method writeStartDocument.
+     * 
+     * @throws XMLStreamException
+     */
+    public void writeStartDocument()
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeStartDocument(  );
+        afterMarkup();
+    } //-- void writeStartDocument()
+
+    /**
+     * Method writeStartDocument.
+     * 
+     * @param version
+     * @throws XMLStreamException
+     */
+    public void writeStartDocument( String version )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeStartDocument( version );
+        afterMarkup();
+    } //-- void writeStartDocument( String )
+
+    /**
+     * Method writeStartDocument.
+     * 
+     * @param encoding
+     * @param version
+     * @throws XMLStreamException
+     */
+    public void writeStartDocument( String encoding, String version )
+        throws XMLStreamException
+    {
+        beforeMarkup();
+        out.writeStartDocument( encoding, version );
+        afterMarkup();
+    } //-- void writeStartDocument( String, String )
+
+    /**
+     * Method writeStartElement.
+     * 
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeStartElement( String localName )
+        throws XMLStreamException
+    {
+        beforeStartElement();
+        out.writeStartElement( localName );
+        afterStartElement();
+    } //-- void writeStartElement( String )
+
+    /**
+     * Method writeStartElement.
+     * 
+     * @param namespaceURI
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeStartElement( String namespaceURI, String localName )
+        throws XMLStreamException
+    {
+        beforeStartElement();
+        out.writeStartElement( namespaceURI, localName );
+        afterStartElement();
+    } //-- void writeStartElement( String, String )
+
+    /**
+     * Method writeStartElement.
+     * 
+     * @param prefix
+     * @param namespaceURI
+     * @param localName
+     * @throws XMLStreamException
+     */
+    public void writeStartElement( String prefix, String localName, String namespaceURI )
+        throws XMLStreamException
+    {
+        beforeStartElement();
+        out.writeStartElement( prefix, localName, namespaceURI );
+        afterStartElement();
+    } //-- void writeStartElement( String, String, String )
+
+    /**
+     * Method afterData.
+     */
+    private void afterData()
+    {
+        states[depth] |= ELEMENT_HAS_DATA;
+    } //-- void afterData()
+
+    /**
+     * Method afterEndElement.
+     */
+    private void afterEndElement()
+    {
+        if ( depth > 0 )
+        {
+            depth--;
+            if ( depth <= 0 )
+            {
+                newLine( 0 );
+            }
+        }
+    } //-- void afterEndElement()
+
+    /**
+     * Method afterMarkup.
+     */
+    private void afterMarkup()
+    {
+        states[depth] |= ELEMENT_HAS_MARKUP;
+    } //-- void afterMarkup()
+
+    /**
+     * Method afterStartElement.
+     */
+    private void afterStartElement()
+    {
+        afterMarkup();
+        depth++;
+    } //-- void afterStartElement()
+
+    /**
+     * Method beforeEndElement.
+     */
+    private void beforeEndElement()
+    {
+        if ( depth > 0 && states[depth] == ELEMENT_HAS_MARKUP )
+        {
+            newLine( depth - 1 );
+        }
+    } //-- void beforeEndElement()
+
+    /**
+     * Method beforeMarkup.
+     */
+    private void beforeMarkup()
+    {
+        int state = states[depth];
+        if ( ( state & ELEMENT_HAS_DATA ) == 0 && ( depth > 0 || state != 0 ) )
+        {
+            newLine( depth );
+            if ( depth > 0 && indent.length() > 0 )
+            {
+                afterMarkup();
+            }
+        }
+    } //-- void beforeMarkup()
+
+    /**
+     * Method beforeStartElement.
+     */
+    private void beforeStartElement()
+    {
+        beforeMarkup();
+        if ( states.length <= depth + 1 )
+        {
+            byte[] tmp = new byte[states.length * 2];
+            System.arraycopy( states, 0, tmp, 0, states.length );
+            states = tmp;
+        }
+        states[depth + 1] = 0;
+    } //-- void beforeStartElement()
+
+    /**
+     * Method getLineSeparator.
+     * 
+     * @return String
+     */
+    public String getLineSeparator()
+    {
+        try
+        {
+            return System.getProperty( "line.separator", NEW_LINE );
+        }
+        catch ( Exception e )
+        {
+            return NEW_LINE;
+        }
+    } //-- String getLineSeparator()
+
+    /**
+     * Method newLine.
+     * 
+     * @param depth
+     */
+    private void newLine( int depth )
+    {
+        try
+        {
+            out.writeCharacters( newLine );
+            int prefixLength = depth * indent.length();
+            while ( linePrefix.length < prefixLength )
+            {
+                char[] tmp = new char[linePrefix.length * 2];
+                System.arraycopy( linePrefix, 0, tmp, 0, linePrefix.length );
+                System.arraycopy( linePrefix, 0, tmp, linePrefix.length, linePrefix.length );
+                linePrefix = tmp;
+            }
+            out.writeCharacters( linePrefix, 0, prefixLength );
+        }
+        catch ( Exception e )
+        {
+        }
+    } //-- void newLine( int )
+
+    /**
+     * Method setNewLine.
+     * 
+     * @param newLine
+     */
+    public void setNewLine( String newLine )
+    {
+        this.newLine = newLine;
+    } //-- void setNewLine( String )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/MetadataStaxReader.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/MetadataStaxReader.java
new file mode 100644
index 0000000..5f9c959
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/MetadataStaxReader.java
@@ -0,0 +1,950 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.metadata.io.stax;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.ByteArrayInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.text.DateFormat;
+import java.text.ParsePosition;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.xml.stream.*;
+import org.fedoraproject.xmvn.metadata.ArtifactAlias;
+import org.fedoraproject.xmvn.metadata.ArtifactMetadata;
+import org.fedoraproject.xmvn.metadata.Dependency;
+import org.fedoraproject.xmvn.metadata.DependencyExclusion;
+import org.fedoraproject.xmvn.metadata.PackageMetadata;
+import org.fedoraproject.xmvn.metadata.SkippedArtifactMetadata;
+
+/**
+ * Class MetadataStaxReader.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class MetadataStaxReader
+{
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method read.
+     * 
+     * @param reader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return PackageMetadata
+     */
+    public PackageMetadata read( Reader reader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        XMLStreamReader xmlStreamReader = XMLInputFactory.newInstance().createXMLStreamReader( reader );
+
+        return read( xmlStreamReader, strict );
+    } //-- PackageMetadata read( Reader, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param reader
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return PackageMetadata
+     */
+    public PackageMetadata read( Reader reader )
+        throws IOException, XMLStreamException
+    {
+        return read( reader, true );
+    } //-- PackageMetadata read( Reader )
+
+    /**
+     * Method read.
+     * 
+     * @param stream
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return PackageMetadata
+     */
+    public PackageMetadata read( InputStream stream, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        XMLStreamReader xmlStreamReader = XMLInputFactory.newInstance().createXMLStreamReader( stream );
+
+        return read( xmlStreamReader, strict );
+    } //-- PackageMetadata read( InputStream, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param stream
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return PackageMetadata
+     */
+    public PackageMetadata read( InputStream stream )
+        throws IOException, XMLStreamException
+    {
+        return read( stream, true );
+    } //-- PackageMetadata read( InputStream )
+
+    /**
+     * Method read.
+     * 
+     * @param filePath
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return PackageMetadata
+     */
+    public PackageMetadata read( String filePath, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        java.io.File file = new java.io.File( filePath );
+        XMLStreamReader xmlStreamReader = XMLInputFactory.newInstance().createXMLStreamReader( file.toURI().toURL().toExternalForm(), new FileInputStream( file ) );
+
+        return read( xmlStreamReader, strict );
+    } //-- PackageMetadata read( String, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param filePath
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return PackageMetadata
+     */
+    public PackageMetadata read( String filePath )
+        throws IOException, XMLStreamException
+    {
+        return read( filePath, true );
+    } //-- PackageMetadata read( String )
+
+    /**
+     * Method checkFieldWithDuplicate.
+     * 
+     * @param xmlStreamReader
+     * @param parsed
+     * @param alias
+     * @param tagName
+     * @throws XMLStreamException
+     * @return boolean
+     */
+    private boolean checkFieldWithDuplicate( XMLStreamReader xmlStreamReader, String tagName, String alias, java.util.Set parsed )
+        throws XMLStreamException
+    {
+        if ( !( xmlStreamReader.getLocalName().equals( tagName ) || xmlStreamReader.getLocalName().equals( alias ) ) )
+        {
+            return false;
+        }
+        if ( !parsed.add( tagName ) )
+        {
+            throw new XMLStreamException( "Duplicated tag: '" + tagName + "'", xmlStreamReader.getLocation() );
+        }
+        return true;
+    } //-- boolean checkFieldWithDuplicate( XMLStreamReader, String, String, java.util.Set )
+
+    /**
+     * Method checkUnknownElement.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws XMLStreamException
+     */
+    private void checkUnknownElement( XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( strict )
+        {
+            throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+        }
+        int unrecognizedTagCount = 1;
+        while( unrecognizedTagCount != 0 )
+        {
+            xmlStreamReader.next();
+            if ( xmlStreamReader.getEventType() == XMLStreamConstants.START_ELEMENT )
+            {
+                unrecognizedTagCount++;
+            }
+            else if ( xmlStreamReader.getEventType() == XMLStreamConstants.END_ELEMENT )
+            {
+                unrecognizedTagCount--;
+            }
+        }
+    } //-- void checkUnknownElement( XMLStreamReader, boolean )
+
+    /**
+     * Method getBooleanValue.
+     * 
+     * @param s
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return boolean
+     */
+    private boolean getBooleanValue( String s, String attribute, XMLStreamReader xmlStreamReader )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            return Boolean.valueOf( s ).booleanValue();
+        }
+        return false;
+    } //-- boolean getBooleanValue( String, String, XMLStreamReader )
+
+    /**
+     * Method getByteValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return byte
+     */
+    private byte getByteValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Byte.valueOf( s ).byteValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a byte but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- byte getByteValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getCharacterValue.
+     * 
+     * @param s
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return char
+     */
+    private char getCharacterValue( String s, String attribute, XMLStreamReader xmlStreamReader )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            return s.charAt( 0 );
+        }
+        return 0;
+    } //-- char getCharacterValue( String, String, XMLStreamReader )
+
+    /**
+     * Method getDateValue.
+     * 
+     * @param s
+     * @param xmlStreamReader
+     * @param dateFormat
+     * @param attribute
+     * @throws XMLStreamException
+     * @return Date
+     */
+    private java.util.Date getDateValue( String s, String attribute, String dateFormat, XMLStreamReader xmlStreamReader )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            String effectiveDateFormat = dateFormat;
+            if ( dateFormat == null )
+            {
+                effectiveDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS";
+            }
+            if ( "long".equals( effectiveDateFormat ) )
+            {
+                try
+                {
+                    return new java.util.Date( Long.parseLong( s ) );
+                }
+                catch ( NumberFormatException e )
+                {
+                    throw new XMLStreamException( e.getMessage(), xmlStreamReader.getLocation(), e );
+                }
+            }
+            else
+            {
+                try
+                {
+                    DateFormat dateParser = new java.text.SimpleDateFormat( effectiveDateFormat, java.util.Locale.US );
+                    return dateParser.parse( s );
+                }
+                catch ( java.text.ParseException e )
+                {
+                    throw new XMLStreamException( e.getMessage(), xmlStreamReader.getLocation(), e );
+                }
+            }
+        }
+        return null;
+    } //-- java.util.Date getDateValue( String, String, String, XMLStreamReader )
+
+    /**
+     * Method getDefaultValue.
+     * 
+     * @param s
+     * @param v
+     * @return String
+     */
+    private String getDefaultValue( String s, String v )
+    {
+        if ( s == null )
+        {
+            s = v;
+        }
+        return s;
+    } //-- String getDefaultValue( String, String )
+
+    /**
+     * Method getDoubleValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return double
+     */
+    private double getDoubleValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Double.valueOf( s ).doubleValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a floating point number but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- double getDoubleValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getFloatValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return float
+     */
+    private float getFloatValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Float.valueOf( s ).floatValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a floating point number but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- float getFloatValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getIntegerValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return int
+     */
+    private int getIntegerValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Integer.valueOf( s ).intValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be an integer but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- int getIntegerValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getLongValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return long
+     */
+    private long getLongValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Long.valueOf( s ).longValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a long integer but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- long getLongValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getRequiredAttributeValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return String
+     */
+    private String getRequiredAttributeValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s == null )
+        {
+            if ( strict )
+            {
+                throw new XMLStreamException( "Missing required value for attribute '" + attribute + "'", xmlStreamReader.getLocation() );
+            }
+        }
+        return s;
+    } //-- String getRequiredAttributeValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getShortValue.
+     * 
+     * @param s
+     * @param strict
+     * @param xmlStreamReader
+     * @param attribute
+     * @throws XMLStreamException
+     * @return short
+     */
+    private short getShortValue( String s, String attribute, XMLStreamReader xmlStreamReader, boolean strict )
+        throws XMLStreamException
+    {
+        if ( s != null )
+        {
+            try
+            {
+                return Short.valueOf( s ).shortValue();
+            }
+            catch ( NumberFormatException nfe )
+            {
+                if ( strict )
+                {
+                    throw new XMLStreamException( "Unable to parse element '" + attribute + "', must be a short integer but was '" + s + "'", xmlStreamReader.getLocation(), nfe );
+                }
+            }
+        }
+        return 0;
+    } //-- short getShortValue( String, String, XMLStreamReader, boolean )
+
+    /**
+     * Method getTrimmedValue.
+     * 
+     * @param s
+     * @return String
+     */
+    private String getTrimmedValue( String s )
+    {
+        if ( s != null )
+        {
+            s = s.trim();
+        }
+        return s;
+    } //-- String getTrimmedValue( String )
+
+    /**
+     * Method nextTag.
+     * 
+     * @param xmlStreamReader
+     * @throws XMLStreamException
+     * @return int
+     */
+    private int nextTag( XMLStreamReader xmlStreamReader )
+        throws XMLStreamException
+    {
+        while ( true )
+        {
+            int eventType = xmlStreamReader.next();
+            switch ( eventType )
+            {
+                case XMLStreamConstants.CHARACTERS:
+                case XMLStreamConstants.CDATA:
+                case XMLStreamConstants.SPACE:
+                case XMLStreamConstants.PROCESSING_INSTRUCTION:
+                case XMLStreamConstants.COMMENT:
+                    break;
+                case XMLStreamConstants.START_ELEMENT:
+                case XMLStreamConstants.END_ELEMENT:
+                    return eventType;
+                default:
+                    throw new XMLStreamException( "expected start or end tag", xmlStreamReader.getLocation() );
+            }
+        }
+    } //-- int nextTag( XMLStreamReader )
+
+    /**
+     * Method parseArtifactAlias.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return ArtifactAlias
+     */
+    private ArtifactAlias parseArtifactAlias( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        ArtifactAlias artifactAlias = new ArtifactAlias();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "groupId", null, parsed ) )
+            {
+                artifactAlias.setGroupId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "artifactId", null, parsed ) )
+            {
+                artifactAlias.setArtifactId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "extension", null, parsed ) )
+            {
+                artifactAlias.setExtension( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "jar" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "classifier", null, parsed ) )
+            {
+                artifactAlias.setClassifier( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return artifactAlias;
+    } //-- ArtifactAlias parseArtifactAlias( XMLStreamReader, boolean )
+
+    /**
+     * Method parseArtifactMetadata.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return ArtifactMetadata
+     */
+    private ArtifactMetadata parseArtifactMetadata( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        ArtifactMetadata artifactMetadata = new ArtifactMetadata();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "groupId", null, parsed ) )
+            {
+                artifactMetadata.setGroupId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "artifactId", null, parsed ) )
+            {
+                artifactMetadata.setArtifactId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "extension", null, parsed ) )
+            {
+                artifactMetadata.setExtension( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "jar" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "classifier", null, parsed ) )
+            {
+                artifactMetadata.setClassifier( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "version", null, parsed ) )
+            {
+                artifactMetadata.setVersion( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "path", null, parsed ) )
+            {
+                artifactMetadata.setPath( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "namespace", null, parsed ) )
+            {
+                artifactMetadata.setNamespace( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "uuid", null, parsed ) )
+            {
+                artifactMetadata.setUuid( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "properties", null, parsed ) )
+            {
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    String key = xmlStreamReader.getLocalName();
+                    String value = xmlStreamReader.getElementText().trim();
+                    artifactMetadata.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "compatVersions", null, parsed ) )
+            {
+                java.util.List compatVersions = new java.util.ArrayList/*<String>*/();
+                artifactMetadata.setCompatVersions( compatVersions );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "version".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        compatVersions.add( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "new java.util.ArrayList/*<String>*/()" ) ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "aliases", null, parsed ) )
+            {
+                java.util.List aliases = new java.util.ArrayList/*<ArtifactAlias>*/();
+                artifactMetadata.setAliases( aliases );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "alias".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        aliases.add( parseArtifactAlias( xmlStreamReader, strict ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "dependencies", null, parsed ) )
+            {
+                java.util.List dependencies = new java.util.ArrayList/*<Dependency>*/();
+                artifactMetadata.setDependencies( dependencies );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "dependency".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        artifactMetadata.addDependency( parseDependency( xmlStreamReader, strict ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return artifactMetadata;
+    } //-- ArtifactMetadata parseArtifactMetadata( XMLStreamReader, boolean )
+
+    /**
+     * Method parseDependency.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return Dependency
+     */
+    private Dependency parseDependency( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        Dependency dependency = new Dependency();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "groupId", null, parsed ) )
+            {
+                dependency.setGroupId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "artifactId", null, parsed ) )
+            {
+                dependency.setArtifactId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "extension", null, parsed ) )
+            {
+                dependency.setExtension( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "jar" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "classifier", null, parsed ) )
+            {
+                dependency.setClassifier( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "requestedVersion", null, parsed ) )
+            {
+                dependency.setRequestedVersion( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "SYSTEM" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "resolvedVersion", null, parsed ) )
+            {
+                dependency.setResolvedVersion( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "SYSTEM" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "namespace", null, parsed ) )
+            {
+                dependency.setNamespace( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "exclusions", null, parsed ) )
+            {
+                java.util.List exclusions = new java.util.ArrayList/*<DependencyExclusion>*/();
+                dependency.setExclusions( exclusions );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "exclusion".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        dependency.addExclusion( parseDependencyExclusion( xmlStreamReader, strict ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return dependency;
+    } //-- Dependency parseDependency( XMLStreamReader, boolean )
+
+    /**
+     * Method parseDependencyExclusion.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return DependencyExclusion
+     */
+    private DependencyExclusion parseDependencyExclusion( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        DependencyExclusion dependencyExclusion = new DependencyExclusion();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "groupId", null, parsed ) )
+            {
+                dependencyExclusion.setGroupId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "artifactId", null, parsed ) )
+            {
+                dependencyExclusion.setArtifactId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return dependencyExclusion;
+    } //-- DependencyExclusion parseDependencyExclusion( XMLStreamReader, boolean )
+
+    /**
+     * Method parsePackageMetadata.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return PackageMetadata
+     */
+    private PackageMetadata parsePackageMetadata( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        PackageMetadata packageMetadata = new PackageMetadata();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "uuid", null, parsed ) )
+            {
+                packageMetadata.setUuid( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "properties", null, parsed ) )
+            {
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    String key = xmlStreamReader.getLocalName();
+                    String value = xmlStreamReader.getElementText().trim();
+                    packageMetadata.addProperty( key, value );
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "artifacts", null, parsed ) )
+            {
+                java.util.List artifacts = new java.util.ArrayList/*<ArtifactMetadata>*/();
+                packageMetadata.setArtifacts( artifacts );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "artifact".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        packageMetadata.addArtifact( parseArtifactMetadata( xmlStreamReader, strict ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "skippedArtifacts", null, parsed ) )
+            {
+                java.util.List skippedArtifacts = new java.util.ArrayList/*<SkippedArtifactMetadata>*/();
+                packageMetadata.setSkippedArtifacts( skippedArtifacts );
+                while ( xmlStreamReader.nextTag() == XMLStreamConstants.START_ELEMENT )
+                {
+                    if ( "skippedArtifact".equals( xmlStreamReader.getLocalName() ) )
+                    {
+                        packageMetadata.addSkippedArtifact( parseSkippedArtifactMetadata( xmlStreamReader, strict ) );
+                    }
+                    else
+                    {
+                        throw new XMLStreamException( "Unrecognised tag: '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation() );
+                    }
+                }
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return packageMetadata;
+    } //-- PackageMetadata parsePackageMetadata( XMLStreamReader, boolean )
+
+    /**
+     * Method parseSkippedArtifactMetadata.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return SkippedArtifactMetadata
+     */
+    private SkippedArtifactMetadata parseSkippedArtifactMetadata( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        SkippedArtifactMetadata skippedArtifactMetadata = new SkippedArtifactMetadata();
+        java.util.Set parsed = new java.util.HashSet();
+        while ( ( strict ? xmlStreamReader.nextTag() : nextTag( xmlStreamReader ) ) == XMLStreamConstants.START_ELEMENT )
+        {
+            if ( checkFieldWithDuplicate( xmlStreamReader, "groupId", null, parsed ) )
+            {
+                skippedArtifactMetadata.setGroupId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "artifactId", null, parsed ) )
+            {
+                skippedArtifactMetadata.setArtifactId( getTrimmedValue( xmlStreamReader.getElementText() ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "extension", null, parsed ) )
+            {
+                skippedArtifactMetadata.setExtension( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "jar" ) ) );
+            }
+            else if ( checkFieldWithDuplicate( xmlStreamReader, "classifier", null, parsed ) )
+            {
+                skippedArtifactMetadata.setClassifier( getTrimmedValue( getDefaultValue( xmlStreamReader.getElementText(), "" ) ) );
+            }
+            else
+            {
+                checkUnknownElement( xmlStreamReader, strict );
+            }
+        }
+        return skippedArtifactMetadata;
+    } //-- SkippedArtifactMetadata parseSkippedArtifactMetadata( XMLStreamReader, boolean )
+
+    /**
+     * Method read.
+     * 
+     * @param xmlStreamReader
+     * @param strict
+     * @throws IOException
+     * @throws XMLStreamException
+     * @return PackageMetadata
+     */
+    private PackageMetadata read( XMLStreamReader xmlStreamReader, boolean strict )
+        throws IOException, XMLStreamException
+    {
+        int eventType = xmlStreamReader.getEventType();
+        String encoding = null;
+        while ( eventType != XMLStreamConstants.END_DOCUMENT )
+        {
+            if ( eventType == XMLStreamConstants.START_DOCUMENT )
+            {
+                encoding = xmlStreamReader.getCharacterEncodingScheme();
+            }
+            if ( eventType == XMLStreamConstants.START_ELEMENT )
+            {
+                if ( strict && ! "metadata".equals( xmlStreamReader.getLocalName() ) )
+                {
+                    throw new XMLStreamException( "Expected root element 'metadata' but found '" + xmlStreamReader.getLocalName() + "'", xmlStreamReader.getLocation(), null );
+                }
+                PackageMetadata packageMetadata = parsePackageMetadata( xmlStreamReader, strict );
+                packageMetadata.setModelEncoding( encoding );
+                resolveReferences( packageMetadata );
+                return packageMetadata;
+            }
+            eventType = xmlStreamReader.next();
+        }
+        throw new XMLStreamException( "Expected root element 'metadata' but found no element at all: invalid XML document", xmlStreamReader.getLocation(), null );
+    } //-- PackageMetadata read( XMLStreamReader, boolean )
+
+    /**
+     * Method resolveReferences.
+     * 
+     * @param value
+     */
+    private void resolveReferences( PackageMetadata value )
+    {
+        java.util.Map refs;
+    } //-- void resolveReferences( PackageMetadata )
+
+}
diff --git a/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/MetadataStaxWriter.java b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/MetadataStaxWriter.java
new file mode 100644
index 0000000..36eddd4
--- /dev/null
+++ b/xmvn-core/target/generated-sources/modello/org/fedoraproject/xmvn/metadata/io/stax/MetadataStaxWriter.java
@@ -0,0 +1,490 @@
+// =================== DO NOT EDIT THIS FILE ====================
+// Generated by Modello 1.8.2,
+// any modifications will be overwritten.
+// ==============================================================
+
+package org.fedoraproject.xmvn.metadata.io.stax;
+
+  //---------------------------------/
+ //- Imported classes and packages -/
+//---------------------------------/
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.text.DateFormat;
+import java.util.Iterator;
+import java.util.Locale;
+import java.util.jar.Manifest;
+import javax.xml.stream.*;
+import org.fedoraproject.xmvn.metadata.ArtifactAlias;
+import org.fedoraproject.xmvn.metadata.ArtifactMetadata;
+import org.fedoraproject.xmvn.metadata.Dependency;
+import org.fedoraproject.xmvn.metadata.DependencyExclusion;
+import org.fedoraproject.xmvn.metadata.PackageMetadata;
+import org.fedoraproject.xmvn.metadata.SkippedArtifactMetadata;
+
+/**
+ * Class MetadataStaxWriter.
+ * 
+ * @version $Revision$ $Date$
+ */
+@SuppressWarnings( "all" )
+public class MetadataStaxWriter
+{
+
+      //--------------------------/
+     //- Class/Member Variables -/
+    //--------------------------/
+
+    /**
+     * Field curId.
+     */
+    private int curId;
+
+    /**
+     * Field idMap.
+     */
+    private java.util.Map idMap;
+
+
+      //----------------/
+     //- Constructors -/
+    //----------------/
+
+    public MetadataStaxWriter()
+    {
+        idMap = new java.util.HashMap();
+    } //-- org.fedoraproject.xmvn.metadata.io.stax.MetadataStaxWriter()
+
+
+      //-----------/
+     //- Methods -/
+    //-----------/
+
+    /**
+     * Method write.
+     * 
+     * @param writer
+     * @param packageMetadata
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    public void write( Writer writer, PackageMetadata packageMetadata )
+        throws java.io.IOException, XMLStreamException
+    {
+        XMLOutputFactory factory = XMLOutputFactory.newInstance();
+        boolean supportWindowsLineEndings = false;
+        if ( factory.isPropertySupported( "com.ctc.wstx.outputEscapeCr" ) )
+        {
+            factory.setProperty( "com.ctc.wstx.outputEscapeCr", Boolean.FALSE );
+            supportWindowsLineEndings = true;
+        }
+        if ( factory.isPropertySupported( "org.codehaus.stax2.automaticEmptyElements" ) )
+        {
+            factory.setProperty( "org.codehaus.stax2.automaticEmptyElements", Boolean.FALSE );
+        }
+        IndentingXMLStreamWriter serializer = new IndentingXMLStreamWriter( factory.createXMLStreamWriter( writer ) );
+        if ( supportWindowsLineEndings )
+        {
+            serializer.setNewLine( serializer.getLineSeparator() );
+        }
+        serializer.writeStartDocument( packageMetadata.getModelEncoding(), "1.0" );
+        writePackageMetadata( packageMetadata, "metadata", serializer );
+        serializer.writeEndDocument();
+    } //-- void write( Writer, PackageMetadata )
+
+    /**
+     * Method write.
+     * 
+     * @param stream
+     * @param packageMetadata
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    public void write( OutputStream stream, PackageMetadata packageMetadata )
+        throws java.io.IOException, XMLStreamException
+    {
+        XMLOutputFactory factory = XMLOutputFactory.newInstance();
+        boolean supportWindowsLineEndings = false;
+        if ( factory.isPropertySupported( "com.ctc.wstx.outputEscapeCr" ) )
+        {
+            factory.setProperty( "com.ctc.wstx.outputEscapeCr", Boolean.FALSE );
+            supportWindowsLineEndings = true;
+        }
+        if ( factory.isPropertySupported( "org.codehaus.stax2.automaticEmptyElements" ) )
+        {
+            factory.setProperty( "org.codehaus.stax2.automaticEmptyElements", Boolean.FALSE );
+        }
+        IndentingXMLStreamWriter serializer = new IndentingXMLStreamWriter( factory.createXMLStreamWriter( stream, packageMetadata.getModelEncoding() ) );
+        if ( supportWindowsLineEndings )
+        {
+            serializer.setNewLine( serializer.getLineSeparator() );
+        }
+        serializer.writeStartDocument( packageMetadata.getModelEncoding(), "1.0" );
+        writePackageMetadata( packageMetadata, "metadata", serializer );
+        serializer.writeEndDocument();
+    } //-- void write( OutputStream, PackageMetadata )
+
+    /**
+     * Method writeArtifactAlias.
+     * 
+     * @param artifactAlias
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeArtifactAlias( ArtifactAlias artifactAlias, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( artifactAlias != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( artifactAlias.getGroupId() != null )
+            {
+                serializer.writeStartElement( "groupId" );
+                serializer.writeCharacters( artifactAlias.getGroupId() );
+                serializer.writeEndElement();
+            }
+            if ( artifactAlias.getArtifactId() != null )
+            {
+                serializer.writeStartElement( "artifactId" );
+                serializer.writeCharacters( artifactAlias.getArtifactId() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifactAlias.getExtension() != null ) && !artifactAlias.getExtension().equals( "jar" ) )
+            {
+                serializer.writeStartElement( "extension" );
+                serializer.writeCharacters( artifactAlias.getExtension() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifactAlias.getClassifier() != null ) && !artifactAlias.getClassifier().equals( "" ) )
+            {
+                serializer.writeStartElement( "classifier" );
+                serializer.writeCharacters( artifactAlias.getClassifier() );
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeArtifactAlias( ArtifactAlias, String, XMLStreamWriter )
+
+    /**
+     * Method writeArtifactMetadata.
+     * 
+     * @param artifactMetadata
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeArtifactMetadata( ArtifactMetadata artifactMetadata, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( artifactMetadata != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( artifactMetadata.getGroupId() != null )
+            {
+                serializer.writeStartElement( "groupId" );
+                serializer.writeCharacters( artifactMetadata.getGroupId() );
+                serializer.writeEndElement();
+            }
+            if ( artifactMetadata.getArtifactId() != null )
+            {
+                serializer.writeStartElement( "artifactId" );
+                serializer.writeCharacters( artifactMetadata.getArtifactId() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifactMetadata.getExtension() != null ) && !artifactMetadata.getExtension().equals( "jar" ) )
+            {
+                serializer.writeStartElement( "extension" );
+                serializer.writeCharacters( artifactMetadata.getExtension() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifactMetadata.getClassifier() != null ) && !artifactMetadata.getClassifier().equals( "" ) )
+            {
+                serializer.writeStartElement( "classifier" );
+                serializer.writeCharacters( artifactMetadata.getClassifier() );
+                serializer.writeEndElement();
+            }
+            if ( artifactMetadata.getVersion() != null )
+            {
+                serializer.writeStartElement( "version" );
+                serializer.writeCharacters( artifactMetadata.getVersion() );
+                serializer.writeEndElement();
+            }
+            if ( artifactMetadata.getPath() != null )
+            {
+                serializer.writeStartElement( "path" );
+                serializer.writeCharacters( artifactMetadata.getPath() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifactMetadata.getNamespace() != null ) && !artifactMetadata.getNamespace().equals( "" ) )
+            {
+                serializer.writeStartElement( "namespace" );
+                serializer.writeCharacters( artifactMetadata.getNamespace() );
+                serializer.writeEndElement();
+            }
+            if ( artifactMetadata.getUuid() != null )
+            {
+                serializer.writeStartElement( "uuid" );
+                serializer.writeCharacters( artifactMetadata.getUuid() );
+                serializer.writeEndElement();
+            }
+            if ( ( artifactMetadata.getProperties() != null ) && ( artifactMetadata.getProperties().size() > 0 ) )
+            {
+                serializer.writeStartElement( "properties" );
+                for ( Iterator iter = artifactMetadata.getProperties().keySet().iterator(); iter.hasNext(); )
+                {
+                    String key = (String) iter.next();
+                    String value = (String) artifactMetadata.getProperties().get( key );
+                    serializer.writeStartElement( "" + key + "" );
+                    serializer.writeCharacters( value );
+                    serializer.writeEndElement();
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( artifactMetadata.getCompatVersions() != null ) && ( artifactMetadata.getCompatVersions().size() > 0 ) )
+            {
+                serializer.writeStartElement( "compatVersions" );
+                for ( Iterator iter = artifactMetadata.getCompatVersions().iterator(); iter.hasNext(); )
+                {
+                    String compatVersion = (String) iter.next();
+                    serializer.writeStartElement( "version" );
+                    serializer.writeCharacters( compatVersion );
+                    serializer.writeEndElement();
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( artifactMetadata.getAliases() != null ) && ( artifactMetadata.getAliases().size() > 0 ) )
+            {
+                serializer.writeStartElement( "aliases" );
+                for ( Iterator iter = artifactMetadata.getAliases().iterator(); iter.hasNext(); )
+                {
+                    ArtifactAlias o = (ArtifactAlias) iter.next();
+                    writeArtifactAlias( o, "alias", serializer );
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( artifactMetadata.getDependencies() != null ) && ( artifactMetadata.getDependencies().size() > 0 ) )
+            {
+                serializer.writeStartElement( "dependencies" );
+                for ( Iterator iter = artifactMetadata.getDependencies().iterator(); iter.hasNext(); )
+                {
+                    Dependency o = (Dependency) iter.next();
+                    writeDependency( o, "dependency", serializer );
+                }
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeArtifactMetadata( ArtifactMetadata, String, XMLStreamWriter )
+
+    /**
+     * Method writeDependency.
+     * 
+     * @param dependency
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeDependency( Dependency dependency, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( dependency != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( dependency.getGroupId() != null )
+            {
+                serializer.writeStartElement( "groupId" );
+                serializer.writeCharacters( dependency.getGroupId() );
+                serializer.writeEndElement();
+            }
+            if ( dependency.getArtifactId() != null )
+            {
+                serializer.writeStartElement( "artifactId" );
+                serializer.writeCharacters( dependency.getArtifactId() );
+                serializer.writeEndElement();
+            }
+            if ( ( dependency.getExtension() != null ) && !dependency.getExtension().equals( "jar" ) )
+            {
+                serializer.writeStartElement( "extension" );
+                serializer.writeCharacters( dependency.getExtension() );
+                serializer.writeEndElement();
+            }
+            if ( ( dependency.getClassifier() != null ) && !dependency.getClassifier().equals( "" ) )
+            {
+                serializer.writeStartElement( "classifier" );
+                serializer.writeCharacters( dependency.getClassifier() );
+                serializer.writeEndElement();
+            }
+            if ( ( dependency.getRequestedVersion() != null ) && !dependency.getRequestedVersion().equals( "SYSTEM" ) )
+            {
+                serializer.writeStartElement( "requestedVersion" );
+                serializer.writeCharacters( dependency.getRequestedVersion() );
+                serializer.writeEndElement();
+            }
+            if ( ( dependency.getResolvedVersion() != null ) && !dependency.getResolvedVersion().equals( "SYSTEM" ) )
+            {
+                serializer.writeStartElement( "resolvedVersion" );
+                serializer.writeCharacters( dependency.getResolvedVersion() );
+                serializer.writeEndElement();
+            }
+            if ( ( dependency.getNamespace() != null ) && !dependency.getNamespace().equals( "" ) )
+            {
+                serializer.writeStartElement( "namespace" );
+                serializer.writeCharacters( dependency.getNamespace() );
+                serializer.writeEndElement();
+            }
+            if ( ( dependency.getExclusions() != null ) && ( dependency.getExclusions().size() > 0 ) )
+            {
+                serializer.writeStartElement( "exclusions" );
+                for ( Iterator iter = dependency.getExclusions().iterator(); iter.hasNext(); )
+                {
+                    DependencyExclusion o = (DependencyExclusion) iter.next();
+                    writeDependencyExclusion( o, "exclusion", serializer );
+                }
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeDependency( Dependency, String, XMLStreamWriter )
+
+    /**
+     * Method writeDependencyExclusion.
+     * 
+     * @param dependencyExclusion
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeDependencyExclusion( DependencyExclusion dependencyExclusion, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( dependencyExclusion != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( dependencyExclusion.getGroupId() != null )
+            {
+                serializer.writeStartElement( "groupId" );
+                serializer.writeCharacters( dependencyExclusion.getGroupId() );
+                serializer.writeEndElement();
+            }
+            if ( dependencyExclusion.getArtifactId() != null )
+            {
+                serializer.writeStartElement( "artifactId" );
+                serializer.writeCharacters( dependencyExclusion.getArtifactId() );
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeDependencyExclusion( DependencyExclusion, String, XMLStreamWriter )
+
+    /**
+     * Method writePackageMetadata.
+     * 
+     * @param packageMetadata
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writePackageMetadata( PackageMetadata packageMetadata, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( packageMetadata != null )
+        {
+            serializer.setDefaultNamespace( "http://fedorahosted.org/xmvn/METADATA/2.0.0" );
+            serializer.writeStartElement( tagName );
+            serializer.writeDefaultNamespace( "http://fedorahosted.org/xmvn/METADATA/2.0.0" );
+            if ( packageMetadata.getUuid() != null )
+            {
+                serializer.writeStartElement( "uuid" );
+                serializer.writeCharacters( packageMetadata.getUuid() );
+                serializer.writeEndElement();
+            }
+            if ( ( packageMetadata.getProperties() != null ) && ( packageMetadata.getProperties().size() > 0 ) )
+            {
+                serializer.writeStartElement( "properties" );
+                for ( Iterator iter = packageMetadata.getProperties().keySet().iterator(); iter.hasNext(); )
+                {
+                    String key = (String) iter.next();
+                    String value = (String) packageMetadata.getProperties().get( key );
+                    serializer.writeStartElement( "" + key + "" );
+                    serializer.writeCharacters( value );
+                    serializer.writeEndElement();
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( packageMetadata.getArtifacts() != null ) && ( packageMetadata.getArtifacts().size() > 0 ) )
+            {
+                serializer.writeStartElement( "artifacts" );
+                for ( Iterator iter = packageMetadata.getArtifacts().iterator(); iter.hasNext(); )
+                {
+                    ArtifactMetadata o = (ArtifactMetadata) iter.next();
+                    writeArtifactMetadata( o, "artifact", serializer );
+                }
+                serializer.writeEndElement();
+            }
+            if ( ( packageMetadata.getSkippedArtifacts() != null ) && ( packageMetadata.getSkippedArtifacts().size() > 0 ) )
+            {
+                serializer.writeStartElement( "skippedArtifacts" );
+                for ( Iterator iter = packageMetadata.getSkippedArtifacts().iterator(); iter.hasNext(); )
+                {
+                    SkippedArtifactMetadata o = (SkippedArtifactMetadata) iter.next();
+                    writeSkippedArtifactMetadata( o, "skippedArtifact", serializer );
+                }
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writePackageMetadata( PackageMetadata, String, XMLStreamWriter )
+
+    /**
+     * Method writeSkippedArtifactMetadata.
+     * 
+     * @param skippedArtifactMetadata
+     * @param serializer
+     * @param tagName
+     * @throws java.io.IOException
+     * @throws XMLStreamException
+     */
+    private void writeSkippedArtifactMetadata( SkippedArtifactMetadata skippedArtifactMetadata, String tagName, XMLStreamWriter serializer )
+        throws java.io.IOException, XMLStreamException
+    {
+        if ( skippedArtifactMetadata != null )
+        {
+            serializer.writeStartElement( tagName );
+            if ( skippedArtifactMetadata.getGroupId() != null )
+            {
+                serializer.writeStartElement( "groupId" );
+                serializer.writeCharacters( skippedArtifactMetadata.getGroupId() );
+                serializer.writeEndElement();
+            }
+            if ( skippedArtifactMetadata.getArtifactId() != null )
+            {
+                serializer.writeStartElement( "artifactId" );
+                serializer.writeCharacters( skippedArtifactMetadata.getArtifactId() );
+                serializer.writeEndElement();
+            }
+            if ( ( skippedArtifactMetadata.getExtension() != null ) && !skippedArtifactMetadata.getExtension().equals( "jar" ) )
+            {
+                serializer.writeStartElement( "extension" );
+                serializer.writeCharacters( skippedArtifactMetadata.getExtension() );
+                serializer.writeEndElement();
+            }
+            if ( ( skippedArtifactMetadata.getClassifier() != null ) && !skippedArtifactMetadata.getClassifier().equals( "" ) )
+            {
+                serializer.writeStartElement( "classifier" );
+                serializer.writeCharacters( skippedArtifactMetadata.getClassifier() );
+                serializer.writeEndElement();
+            }
+            serializer.writeEndElement();
+        }
+    } //-- void writeSkippedArtifactMetadata( SkippedArtifactMetadata, String, XMLStreamWriter )
+
+}
diff --git a/xmvn-parent/pom.xml b/xmvn-parent/pom.xml
index 5f7544b..9ed9ff0 100644
--- a/xmvn-parent/pom.xml
+++ b/xmvn-parent/pom.xml
@@ -104,7 +104,7 @@
     <junitVersion>4.11</junitVersion>
     <jxrPluginVersion>2.3</jxrPluginVersion>
     <mavenWagonVersion>1.0</mavenWagonVersion>
-    <modelloVersion>1.8.2</modelloVersion>
+    <modelloVersion>1.7</modelloVersion>
     <pmdPluginVersion>3.0.1</pmdPluginVersion>
     <projectInfoReportsPluginVersion>2.7</projectInfoReportsPluginVersion>
     <resourcesPluginVersion>2.7</resourcesPluginVersion>
-- 
2.5.0

